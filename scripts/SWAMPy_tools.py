# -*- coding: utf-8 -*-
"""
/***************************************************************************
 swampy
                                 A QGIS plugin
 Salt Water intrusion Analysis Modelling Pluging 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-10-12
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Daniel Zamrsky
        email                : daniel.zamrsky@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, pyqtSlot
from PyQt5.QtGui import QIcon, QStandardItem, QColor
from PyQt5.QtWidgets import QAction, QFileDialog, QMessageBox, QVBoxLayout, QListWidgetItem, QDialog, QLabel, QHBoxLayout
from qgis.core import QgsProject, Qgis, QgsVectorLayer, QgsPointXY, QgsFeature, QgsPoint, QgsGeometry, QgsWkbTypes
from qgis.core import QgsRasterLayer, QgsProcessingContext, QgsTaskManager, QgsTask, QgsProcessingAlgRunnerTask, QgsProcessingFeedback, QgsApplication, QgsMessageLog

from qgis.gui import QgsRubberBand
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar

from .resources import *
from .scripts.swampy_tools import *

# Import the code for the DockWidget
from .SWAMPy_tools_dockwidget import swampyDockWidget
from .scripts.swampy_tools import SwampyTools
from .scripts._modelViewTools import ModelPlotCanvas, ModelListTable, ListWidget, IboundArrayPlotCanvas, GeologyArrayPlotCanvas, ICArrayPlotCanvas
from .scripts._modelViewTools import readNetcdf, readNetcdfSEAWATModelInput, updateNetcdfGeologyArray, updateNetcdfICSalinityArray, updateNetcdfICHeadsArray, readNetcdf_SEAWAT
from .scripts._qTableWidget_tools import BC_inputTable, SEAWAT_parameters_testTable
from .scripts._map_tools import CoordTool
from .scripts._SEAWAT_model_tools import CS_model, SEAWAT_model, interpolate_salinity_arr, save_SEAWAT_pckg_dictionaries, merge_SEAWAT_netcdf_files, run_model_QgSTask, run_model_QgSTask_completed, interpolate_salinity_arr_QgSTask, interpolate_salinity_arr_QgSTask_completed
from .scripts._SEAWAT_geology_tools import create_geology_profile, save_geo_dict

import os.path
import os
import random
import pandas as pd
import numpy as np
import math

MESSAGE_CATEGORY = 'TaskFromFunction'

class swampy:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'swampy_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.action = QAction(QIcon(":/plugins/swampy/icon.png"), "SWAMPY", self.iface.mainWindow())
        self.menu = self.tr(u'&swampy')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'swampy')
        self.toolbar.setObjectName(u'swampy')

        #print "** INITIALIZING swampy"

        self.pluginIsActive = False
        self.dockwidget = None
 

    
    """ ------------------------------------------------------------------- """
    """                     Actions defined below                           """
    """ ------------------------------------------------------------------- """    

    #   choose file path from folder system
    def select_coastline_file(self):
      filename, _filter = QFileDialog.getOpenFileName(
        self.dockwidget, "Select coastline (.shp) file ","", '*.shp')
      self.dockwidget.selectCoastline.setText(filename)

    #   choose file path from folder system
    #def select_coastline_nodes_file(self):
    #  filename, _filter = QFileDialog.getOpenFileName(
    #    self.dockwidget, "Select coastline nodes (.shp) file ","", '*.shp')
    #  self.dockwidget.selectCoastlineNodes.setText(filename)
      
    #   choose file path from folder system
    def select_model_nc_file(self):
      self.netcdf_dirname = QFileDialog.getExistingDirectory(self.dockwidget, 'Select directory') 
      #filename, _filter = QFileDialog.getOpenFolderName(
      #  self.dockwidget, "Select model input (.nc) file ","", '*.nc')
      self.dockwidget.selectModelFiles.setText(self.netcdf_dirname)      

    #   the button that loads in the coastline shapefile
    def load_coastline_shapefile(self):
        #   get a list of models in the folder 
        model_folder = self.dockwidget.selectModelFiles.text()
        model_lst = []
        for fname in os.listdir(model_folder):
            model_lst.append(fname.split('.')[0].split('SRM_')[0] + fname.split('.')[0].split('SRM_')[1])
        #   now create a style for the coastline, only two categories
        self.cst_layer = QgsVectorLayer(self.dockwidget.selectCoastline.text(), '', 'ogr')
        self.cst_layer.startEditing()
        for feature in self.cst_layer.getFeatures():
            if feature['id_srm'] in ['0016_13', '0016_14']:
                #print(feature.id(), feature['id_srm'])
                feature['model'] = 1
            elif feature['id_srm'] == '-1':
                feature['model'] = -1
            else:
                feature['model'] = 0
            self.cst_layer.updateFeature(feature)
        self.cst_layer.commitChanges()  

        #   free the memory and add the layer to the map 
        del self.cst_layer
        self.iface.addVectorLayer(self.dockwidget.selectCoastline.text(), '', 'ogr')
        #   apply a style to the coastline layer
        categorized_renderer = QgsCategorizedSymbolRenderer()
        categorized_renderer.setClassAttribute('model')
        #   create 3 symbols for the different categories of models available
        symbol_1 = QgsLineSymbol.createSimple({'color': '#6fdefd', 'line_width': '2'})
        symbol_2 = QgsLineSymbol.createSimple({'color': '#a4fa6e', 'line_width': '0.75'})
        symbol_3 = QgsLineSymbol.createSimple({'color': '#b6b4b8', 'line_width': '0.5'})
        cat1 = QgsRendererCategory(1, symbol_1, 'Available models')
        cat2 = QgsRendererCategory(0, symbol_2, 'Downloadable models')
        cat3 = QgsRendererCategory(-1, symbol_3, 'No models')
        categorized_renderer.addCategory(cat1)
        categorized_renderer.addCategory(cat2)
        categorized_renderer.addCategory(cat3)
        #   apply the categorized style to the coastline layer
        self.iface.activeLayer().setRenderer(categorized_renderer)
        self.iface.activeLayer().triggerRepaint()
        
        #   in the dockwidget go to the next tab automatically
        self.dockwidget.mainTabWidget.setCurrentIndex(1)

        #   add the layer with the nodes
        #self.iface.addVectorLayer(self.dockwidget.selectCoastlineNodes.text(), '', 'ogr')
    
        #   zoom into the area around the models available
        self.iface.activeLayer().selectByExpression('"model"=1')
        selection = self.iface.activeLayer().selectedFeatures()
        box = self.iface.activeLayer().boundingBoxOfSelected()
        box.scale(5, box.center()[0], box.center()[1])
        self.iface.activeLayer().removeSelection()
        self.iface.mapCanvas().setExtent(box)

    #   plot a line between two points of the cross-section 
    """
    csv_dir = r'g:\_modelbuilder\swampy\data\test_model14\temp_files\cs_points.csv'
    inl_dist = -16.1
    off_dist = 44.9
    cs_name = 'test_model14'
    """
    def plotCsLine(self, inl_dist, off_dist, cs_name, csv_dir):
        #   find the row in the csv with the inland and offshore distances, and then get coordinates 
        df_in = pd.read_csv(csv_dir)
        inl_row = df_in.loc[df_in['dist_coast_m'] == inl_dist * 1000.]
        off_row = df_in.loc[df_in['dist_coast_m'] == off_dist * 1000.]
        #   check that the inl row and off row are not empty - this can sometimes happen when the inl and off dist dont exactly match the start and end values in the csv file,
        #   if it happens then just read row with the minimum and maximum distance
        if len(inl_row) == 0:
            inl_row = df_in.loc[df_in['dist_coast_m'] == min(df_in['dist_coast_m'].values)]
        if len(off_row) == 0:
            off_row = df_in.loc[df_in['dist_coast_m'] == max(df_in['dist_coast_m'].values)]        
        #   plot the line on the canvas
        v_layer = QgsVectorLayer("LineString", cs_name, "memory")
        pr = v_layer.dataProvider()
        seg = QgsFeature()
        points = [QgsPoint(inl_row['x_wgs84'].values[0], inl_row['y_wgs84'].values[0]), QgsPoint(off_row['x_wgs84'].values[0], off_row['y_wgs84'].values[0])]
        seg.setGeometry(QgsGeometry.fromPolyline(points))
        pr.addFeatures([seg])
        QgsProject.instance().addMapLayers([v_layer], False)
        r = QgsRubberBand(self.iface.mapCanvas(), QgsWkbTypes.LineGeometry)  # False = not a polygon
        r.setColor(QColor(0,0,255))
        r.setWidth(3)
        r.setToGeometry(QgsGeometry.fromPolyline(points), None)
    
    #   define the action to load model from selection, there are some conditions that have
    #   to be met, if not print out error warnings explaining whats going wrong
    def add(self):
        act_layer = self.iface.activeLayer()
        selection = self.iface.activeLayer().selectedFeatures()
        if act_layer.name() != '_coastline':
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Error")
            msg.setInformativeText('Please select the "_coastline" layer as active layer!')
            msg.setWindowTitle("Error")
            msg.exec_()
        elif act_layer.name() == '_coastline' and len(selection) == 0:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Error")
            msg.setInformativeText('No features from the "_coastline" layer are selected!')
            msg.setWindowTitle("Error")
            msg.exec_()
        #   if all the errors are avoided load the model into the table
        else:
            #   loop through all the selected layers
            for i in selection:
                #   if the model is already in the list dont add it again
                if i['id_srm'] in self.model.model_list:
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Critical)
                    msg.setText("Warning")
                    msg.setInformativeText('This model is already loaded in and wont be loaded again.')
                    msg.setWindowTitle("Warning")
                    msg.exec_()                    
                else:
                    self.model.model_list.append(i['id_srm'])
                    self.model.layoutChanged.emit()
                    #   load tha netcdf file, define the directory where netcdf files are stored
                    #   first check if the file exists
                    nc_path = os.path.join(self.dockwidget.selectModelFiles.text(), i['id_srm'].split('_')[0] + '_SRM_' + i['id_srm'].split('_')[1] + '.nc')
                    if os.path.isfile(nc_path):
                        self.nc_dataset = readNetcdf(nc_path)
                        self.updateSpinBoxes(self.nc_dataset[1], self.nc_dataset[2])
                        self.timestep = 0
                        self.plotWdg.plotConcProfile(self.nc_dataset[0], self.timestep, self.dockwidget.rcpComboBox.currentText(), self.dockwidget.demComboBox.currentText(),\
                                                     self.dockwidget.xminSpinBox.value(), self.dockwidget.xmaxSpinBox.value(), self.dockwidget.yminSpinBox.value(), self.dockwidget.ymaxSpinBox.value())   
                        #   set texts and values for the zoom and time slider
                        self.dockwidget.ts_label.setText(str(0))
                        self.dockwidget.ts_horizontalBar.setValue(35)
                        #   set the initial values and steps for the sliders
                    else:
                        msg = QMessageBox()
                        msg.setIcon(QMessageBox.Critical)
                        msg.setText("Error")
                        msg.setInformativeText('File  ' + nc_path + '  doesnt exist!')
                        msg.setWindowTitle("Error")
                        msg.exec_()                        

    #   action to update the spinboxes with coordinates
    def updateSpinBoxes(self, xcoord, ycoord):
        self.dockwidget.xmaxSpinBox.setMinimum(xcoord[1])
        self.dockwidget.xmaxSpinBox.setMaximum(xcoord[-1])
        self.dockwidget.xmaxSpinBox.setValue(xcoord[-1])
        self.dockwidget.xminSpinBox.setMinimum(xcoord[0])
        self.dockwidget.xminSpinBox.setMaximum(xcoord[-2])
        self.dockwidget.xminSpinBox.setValue(xcoord[0])        
        self.dockwidget.ymaxSpinBox.setMinimum(ycoord[-2])
        self.dockwidget.ymaxSpinBox.setMaximum(ycoord[0])            
        self.dockwidget.ymaxSpinBox.setValue(ycoord[0])
        self.dockwidget.yminSpinBox.setMaximum(ycoord[1])
        self.dockwidget.yminSpinBox.setMinimum(ycoord[-1])        
        self.dockwidget.yminSpinBox.setValue(ycoord[-1]) 

    #   action that plots a selected model from the listview
    def onClickedRow(self, index = None):
        #   plot the selected profile 
        cs_srm_selected = str(self.model.data(index, Qt.DisplayRole))
        nc_path = os.path.join(self.dockwidget.selectModelFiles.text(), cs_srm_selected.split('_')[0] + '_SRM_' + cs_srm_selected.split('_')[1] + '.nc')
        self.nc_dataset = readNetcdf(nc_path)
        self.plotWdg.plotConcProfile(self.nc_dataset[0], self.timestep, self.dockwidget.rcpComboBox.currentText(), self.dockwidget.demComboBox.currentText(),\
                                     self.dockwidget.xminSpinBox.value(), self.dockwidget.xmaxSpinBox.value(), self.dockwidget.yminSpinBox.value(), self.dockwidget.ymaxSpinBox.value())       
        if self.dockwidget.fixZoomCheckBox.isChecked() == True:
            pass
        else:
            self.updateSpinBoxes(self.nc_dataset[1], self.nc_dataset[2])  
        
    #   action for the remove button - removes the item from the list and deletes the netcdf from memory
    def delete(self):
        #indexes = self.customLstView.selectedIndexes()
        indexes = self.dockwidget.listView.selectedIndexes()
        if indexes:
            # Indexes is a list of a single item in single-select mode.
            index = indexes[0]
            # Remove the item and refresh.
            del self.model.model_list[index.row()]
            self.model.layoutChanged.emit()

    """                 PLOTTING CHANGES - ZOOMS ETC.                       """
    #   define the function for the time slide bar, need to define a dictionary with values (1-45 paired with the time steps in NETCDF files)
    def changedValue(self):
        #   define the list of timesteps
        ts_lst = [0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000,\
                  20000, 21000, 22000, 23000, 24000, 25000, 26000, 27000, 28000, 28500, 29000, 29500, 29600, 29800, 30000, 30050, 30100, 30150,\
                  30200, 30250, 30300, 30350, 30400, 30450, 30500]
        sel_times_lst_new = [x - 30000 for x in ts_lst]
        self.timestep = sel_times_lst_new[self.dockwidget.ts_horizontalBar.value() - 1]
        self.dockwidget.ts_label.setText(str(self.timestep))
        
        #   check that a model is selected from the list view
        #model_selected = self.dockwidget.listView.currentRow() 
        #model_selected = self.customLstView.selectionModel().selectedIndexes()
        
        #model_selected = self.dockwidget.listView.selectionModel().selectedIndexes()
        #if len(model_selected) > 0:
        self.plotWdg.plotConcProfile(self.nc_dataset[0], self.timestep, self.dockwidget.rcpComboBox.currentText(), self.dockwidget.demComboBox.currentText(),\
                                     self.dockwidget.xminSpinBox.value(), self.dockwidget.xmaxSpinBox.value(), self.dockwidget.yminSpinBox.value(), self.dockwidget.ymaxSpinBox.value())
    
    #   on change actions of the spinboxes
    def zoomPlot(self):
        self.plotWdg.zoom(self.dockwidget.xminSpinBox.value(), self.dockwidget.xmaxSpinBox.value(), self.dockwidget.yminSpinBox.value(), self.dockwidget.ymaxSpinBox.value())  

    #   on change actions of the RCP and DEM menus
    def rcpDemChange(self):
        self.plotWdg.plotConcProfile(self.nc_dataset[0], self.timestep, self.dockwidget.rcpComboBox.currentText(), self.dockwidget.demComboBox.currentText(),\
                                     self.dockwidget.xminSpinBox.value(), self.dockwidget.xmaxSpinBox.value(), self.dockwidget.yminSpinBox.value(), self.dockwidget.ymaxSpinBox.value())
      
    #   if clicked reset zoom to the full extent of the selected model
    def resetZoom(self):
        self.plotWdg.zoom(self.nc_dataset[1][0], self.nc_dataset[1][-1], self.nc_dataset[2][-1], self.nc_dataset[2][0])  
        #   set the zoom values back to the extent of the model
        self.updateSpinBoxes(self.nc_dataset[1], self.nc_dataset[2])
        
    """
    #  get coordinates for the inland boundary
    def getInlandXY(self):
        canvas_clicked = ClickedPoint(self.iface.mapCanvas())
        coords = self.iface.mapCanvas().setMapTool(canvas_clicked)         
        self.dockwidget.xInlandCoord.setText(coords[0])
        self.dockwidget.yInlandCoord.setText(coords[1])        
    
        
    def display_point(self, pointTool): 
        #self.dockwidget.xInlandCoord.setText(pointTool.x())
        #self.dockwidget.yInlandCoord.setText(pointTool.y())          
        return pointTool[0], pointTool[1]
        #print ('{:.4f}, {:.4f})'.format(pointTool[0], pointTool[1]))    
    
    def getPointCoordinates(self):
        # this QGIS tool emits as QgsPoint after each click on the map canvas
        self.tool = CoordTool(self.iface.mapCanvas())
        self.iface.mapCanvas().setMapTool(self.tool)
        #pt_coord = self.tool.canvasClicked()    
        #pt_coords = tool.canvasReleaseEvent()

        #canvas_clicked = PrintClickedPoint( self.iface.mapCanvas() )
        #pt_coord = self.iface.mapCanvas().setMapTool( canvas_clicked ) 
        #return pt_coord

        #self.iface.mapCanvas().unsetMapTool(tool)        
        #self.pointTool = QgsMapToolEmitPoint(self.iface.mapCanvas())
        #pt_coord = self.pointTool.canvasClicked.connect(self.display_point)        
        #self.dockwidget.xInlandCoord.setText(str(self.tool.point.x()))
        #self.dockwidget.yInlandCoord.setText(str(self.tool.point.y()))   
    """     
        
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('swampy', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/swampy/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'SWAMPY-tools'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING swampy"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD swampy"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&swampy'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar


    """  ------------------------------------------------------------ 
         Tools for loading datasets                               """
         
    #   choose file path from folder system
    def inputDta_select_DEM(self):
        filename, _filter = QFileDialog.getOpenFileName(self.dockwidget, "Select DEM input file ", "", '(*.nc *.asc *.tif *.tiff)')
        self.dockwidget.DEMLineEdit.setText(filename)
    #   choose file path from folder system
    def inputDta_select_CstFeatures(self):
        filename, _filter = QFileDialog.getOpenFileName(self.dockwidget, "Select Coastal features file ", "", '*.shp')
        self.dockwidget.CstFeaturesLineEdit.setText(filename)
    #   choose file path from folder system
    def inputDta_select_CstThk(self):
        filename, _filter = QFileDialog.getOpenFileName(self.dockwidget, "Select Coastal thickness input file ", "", '*.shp')
        self.dockwidget.CstThkLineEdit.setText(filename)
    #   choose file path from folder system
    def inputDta_select_UpperSedThk(self):
        filename, _filter = QFileDialog.getOpenFileName(self.dockwidget, "Select Upper Sediment thickness input file ", "", '(*.nc *.asc *.tif *.tiff)')
        self.dockwidget.UpperSedThkLineEdit.setText(filename)
    #   choose file path from folder system
    def inputDta_select_HkAqf(self):
        filename, _filter = QFileDialog.getOpenFileName(self.dockwidget, "Select Hk (aquifer) input file ", "", '(*.nc *.asc *.tif *.tiff)')
        self.dockwidget.AqfHkLineEdit.setText(filename)
    #   choose file path from folder system
    def inputDta_select_HkAqt(self):
        filename, _filter = QFileDialog.getOpenFileName(self.dockwidget, "Select Hk (aquitard) input file ", "", '(*.nc *.asc *.tif *.tiff)')
        self.dockwidget.AqtHkLineEdit.setText(filename)
    #   choose file path from folder system
    def inputDta_select_GeoHeterogeneity(self):
        filename, _filter = QFileDialog.getOpenFileName(self.dockwidget, "Select Geological Heterogeneity input file ", "", '*.shp')
        self.dockwidget.GeoHeterogeneityLineEdit.setText(filename)
    #   choose file path from folder system
    def inputDta_select_SEAWAT(self):
        filename, _filter = QFileDialog.getOpenFileName(self.dockwidget, "Select SEAWAT executable file ", "", '*.exe')
        self.dockwidget.SEAWATLineEdit.setText(filename)        
    #   choose file path from folder system
    def inputDta_select_output_dir(self):
        self.output_dirname = QFileDialog.getExistingDirectory(self.dockwidget, "Select output directory ") 
        self.dockwidget.outDirLineEdit.setText(self.output_dirname)   
    #   select directory with recharge rates
    def inputDta_select_Rch(self):
        self.rch_dirname = QFileDialog.getExistingDirectory(self.dockwidget, "Select RCH rate (m/d) input file ") 
        self.dockwidget.RchLineEdit.setText(self.rch_dirname)      
        # loop through the directory and add all rasters to a list
        self.rch_lst_files = []
        for file in os.listdir(self.rch_dirname):
             filename = os.fsdecode(file)
             if filename.endswith(".tif") or filename.endswith(".asc") or filename.endswith(".tiff") or filename.endswith(".nc"): 
                 self.rch_lst_files.append(filename)  
      
    #   save the directories into numpy dictionary
    def save_dirs(self):
        #   create new dictionary
        dict_out = {}
        #dict_out['cst_layer_dir'] = self.dockwidget.selectCoastlineNodes.text()
        dict_out['SEAWAT_model_layer_dir'] = self.dockwidget.selectCoastline.text()
        dict_out['SEAWAT_model_source_dir'] = self.dockwidget.selectModelFiles.text()        
        dict_out['dem_dir'] = self.dockwidget.DEMLineEdit.text()
        dict_out['cst_features_dir'] = self.dockwidget.CstFeaturesLineEdit.text()
        dict_out['cst_thk_dir'] = self.dockwidget.CstThkLineEdit.text()
        dict_out['upp_sed_thk_dir'] = self.dockwidget.UpperSedThkLineEdit.text()
        dict_out['hk_aqf_dir'] = self.dockwidget.AqfHkLineEdit.text()
        dict_out['hk_aqt_dir'] = self.dockwidget.AqtHkLineEdit.text()
        dict_out['geo_hetero_dir'] = self.dockwidget.GeoHeterogeneityLineEdit.text()
        dict_out['rch_dir'] = self.dockwidget.RchLineEdit.text()
        dict_out['seawat_dir'] = self.dockwidget.SEAWATLineEdit.text()
        dict_out['out_dir'] = self.dockwidget.outDirLineEdit.text()
        #   create the save file dialog
        fileName, _ = QFileDialog.getSaveFileName(self.dockwidget, "QFileDialog.getSaveFileName()", "", "Numpy dictionary (*.npy)")
        #   save the actual numpy dictionary
        if fileName:
            np.save(fileName, dict_out)

    #   load the directories from the numpy dictionary
    def load_dirs(self):
        #   create the open file dialog and let user select numpy dictionary
        fileName, _ = QFileDialog.getOpenFileName(self.dockwidget, "QFileDialog.getSaveFileName()", "", "Numpy dictionary (*.npy)")
        #   load the numpy dictionary
        if fileName:
            dir_dict_in = np.load(fileName, allow_pickle = True)
            #self.dockwidget.selectCoastlineNodes.setText(dir_dict_in.item()['cst_layer_dir'])
            self.dockwidget.selectCoastline.setText(dir_dict_in.item()['SEAWAT_model_layer_dir'])
            self.dockwidget.selectModelFiles.setText(dir_dict_in.item()['SEAWAT_model_source_dir'])  
            self.dockwidget.DEMLineEdit.setText(dir_dict_in.item()['dem_dir'])
            self.dockwidget.CstFeaturesLineEdit.setText(dir_dict_in.item()['cst_features_dir'])
            self.dockwidget.CstThkLineEdit.setText(dir_dict_in.item()['cst_thk_dir'])
            self.dockwidget.UpperSedThkLineEdit.setText(dir_dict_in.item()['upp_sed_thk_dir'])
            self.dockwidget.AqfHkLineEdit.setText(dir_dict_in.item()['hk_aqf_dir'])
            self.dockwidget.AqtHkLineEdit.setText(dir_dict_in.item()['hk_aqt_dir'])
            self.dockwidget.GeoHeterogeneityLineEdit.setText(dir_dict_in.item()['geo_hetero_dir'])
            self.dockwidget.RchLineEdit.setText(dir_dict_in.item()['rch_dir'])
            self.dockwidget.SEAWATLineEdit.setText(dir_dict_in.item()['seawat_dir'])
            self.dockwidget.outDirLineEdit.setText(dir_dict_in.item()['out_dir'])

    #   load raster or vector layers into the map
    def load_DEM_to_map(self):
        self.iface.addRasterLayer(self.dockwidget.DEMLineEdit.text(), 'DEM')
    def load_CstFeatures_to_map(self):
        self.iface.addVectorLayer(self.dockwidget.CstFeaturesLineEdit.text(), '', 'ogr')
    def load_cst_thk_to_map(self):
        self.iface.addVectorLayer(self.dockwidget.CstThkLineEdit.text(), '', 'ogr')
    def load_upp_sed_thk_to_map(self):
        self.iface.addRasterLayer(self.dockwidget.UpperSedThkLineEdit.text(), 'upper sediment thickness')
    def load_hk_aqf_to_map(self):
        self.iface.addRasterLayer(self.dockwidget.AqfHkLineEdit.text(), 'Hk aquifer layers')
    def load_hk_aqt_to_map(self):
        self.iface.addRasterLayer(self.dockwidget.AqtHkLineEdit.text(), 'Hk aquitard layers')
    def load_geo_hetero_to_map(self):
        self.iface.addVectorLayer(self.dockwidget.GeoHeterogeneityLineEdit.text(), '', 'ogr')

    #   load raster layer into the map
    def load_raster_layer_to_map_from_folder(self):
        for file in os.listdir(self.dockwidget.RchLineEdit.text()):
             filename = os.fsdecode(file)
             if filename.endswith(".tif") or filename.endswith(".asc") or filename.endswith(".tiff") or filename.endswith(".nc"): 
                 self.iface.addRasterLayer(os.path.join(self.dockwidget.RchLineEdit.text(), filename), filename)
                 #  also add to the RCH file list which will be then added to combobox in the SP table

    """  ------------------------------------------------------------ 
         Tools for geology tab                                    """
         
    #   get geological heterogeneity values from the shapefile
    def getGeoHeterogeneityVals(self):
        #   check if the input dir is not empty
        if os.path.exists(self.dockwidget.GeoHeterogeneityLineEdit.text()):
            #   get the coastal point of the selected geology model
            for feature in QgsVectorLayer(os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', 'cs_point.shp'), "cs_point", "ogr").getFeatures():
                cs_point = feature.geometry()           
            #   clip the ate points in a buffer around the coastal point
            layer = QgsVectorLayer(self.dockwidget.GeoHeterogeneityLineEdit.text(), "geo_hetero", "ogr")
            min_dist = 1.
            #   loop through all the polygon features and find the closest one to the coastal point
            for polygon in layer.getFeatures():
                geom = polygon.geometry()
                distanceToPolygon = QgsGeometry.distance(cs_point, geom)
                if distanceToPolygon < min_dist:
                    if not polygon['QS']:
                        pass
                    else:
                        #   find the right index
                        if int(polygon['QS']) == 1:
                            text = 'low'
                        elif int(polygon['QS']) == 2:
                            text = 'medium'
                        else:
                            text = 'high'
                        #   set the combobox value
                        index = self.dockwidget.sedFluxComboBox.findText(text, Qt.MatchFixedString)
                        if index >= 0:
                             self.dockwidget.sedFluxComboBox.setCurrentIndex(index)                    
                        #self.dockwidget.sedFluxComboBox.setCurrentIndex(int(polygon['QS']))
                        self.dockwidget.sandPctSpinBox.setValue(float(polygon['Sand_gl']))
                        self.dockwidget.mudPctSpinBox.setValue(float(polygon['Mud_gl']))
                        #   get the average HK values (mean and stdev) for aquifer and aquitard
                        df_in = pd.read_csv(os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', 'cs_points.csv'))                   
                        #   select all non-Nan values 
                        hk_aqf_lst = [i for i in df_in['hk_aqf_dir'].values.tolist() if not math.isnan(i)]
                        hk_aqt_lst = [i for i in df_in['hk_aqt_dir'].values.tolist() if not math.isnan(i)]                         
                        self.dockwidget.hkAqfMeanSpinBox.setValue(round(np.mean(np.array(hk_aqf_lst)), 4))
                        self.dockwidget.hkAqfStdevSpinBox.setValue(round(np.std(np.array(hk_aqf_lst)), 4))
                        self.dockwidget.hkAqtMeanSpinBox.setValue(round(np.mean(np.array(hk_aqt_lst)), 6))
                        self.dockwidget.hkAqtStdevSpinBox.setValue(round(np.std(np.array(hk_aqt_lst)), 6))                    

    """  ------------------------------------------------------------ 
         Tools for the Stress Period tab                          """

    #   function that reads in all the RCH files from a folder - to be populated into the combobox in the SP tab
    def load_RCH_files_from_folder(self):
        self.rch_files_lst = []
        if os.path.exists(self.dockwidget.RchLineEdit.text()):
            for file in os.listdir(self.dockwidget.RchLineEdit.text()):
                 filename = os.fsdecode(file)
                 if filename.endswith(".tif") or filename.endswith(".asc") or filename.endswith(".tiff") or filename.endswith(".nc"): 
                     self.rch_files_lst.append(filename)

    """  ------------------------------------------------------------ 
         Tools for the Initial conditions tab                     """
         
    #   on change actions of the IC type combobox
    def icComboboxChange(self):
        #   the try except is here to avoid warning because self.nc_dataset doesnt exist yet.. 
        try:
            nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.initial_conditions_selected, 'temp_files', self.initial_conditions_selected + '_INPUT.nc')
            self.nc_dataset = readNetcdfSEAWATModelInput(nc_path)   
            #   plot the IC array based on combobox selection
            if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
                self.ic_plotWdg.plotSalinityArray(self.nc_dataset[13], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
            else:
                self.ic_plotWdg.plotHeadElevationArray(self.nc_dataset[12], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        except AttributeError:
            pass
                    
    #   on change actions of the Head IC type combobox
    def icHeadComboboxChange(self):
        #   the try except is here to avoid warning because self.nc_dataset doesnt exist yet.. 
        try:
            nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.initial_conditions_selected, 'temp_files', self.initial_conditions_selected + '_INPUT.nc')
            self.nc_dataset = readNetcdfSEAWATModelInput(nc_path)   
            self.ic_head_array = self.nc_dataset[12]
            self.topo = self.nc_dataset[3]           
        except AttributeError:
            pass        
        #   based on different options perform different tasks
        if self.dockwidget.ICHeadComboBox.currentText() == 'Constant':
            self.dockwidget.ICHeadDoubleSpinBox.setDisabled(False)
            self.ic_head_array[~np.isnan(self.ic_head_array)] = self.dockwidget.ICHeadDoubleSpinBox.value()
        elif self.dockwidget.ICHeadComboBox.currentText() == 'Topography based':
            #   disable the spinbox for constant values
            self.dockwidget.ICHeadDoubleSpinBox.setDisabled(True)
            for i in range(self.ic_head_array.shape[-1]):
                for j in range(self.ic_head_array.shape[0]):
                    if not math.isnan(self.ic_head_array[j, i]):        
                        self.ic_head_array[j, i] = self.topo[i]
        #   plot the heads
        if self.dockwidget.ICPlotComboBox.currentText() != 'Salinity':
            self.ic_plotWdg.plotHeadElevationArray(self.ic_head_array, self.topo, self.nc_dataset[0], self.nc_dataset[1])                

    #   get timesteps and sea level from the filename netcdf file
    def getIcFileTimestepsSealevel(self):
        filedir = os.path.join(self.dockwidget.selectModelFiles.text(), self.dockwidget.selectICFileComboBox.currentText())
        #   read the netcdf file
        time_steps = readNetcdf(filedir)[0]['time'].values.tolist()
        time_steps = [str(i) for i in time_steps]
        #rcps = readNetcdf(filedir)[0]['rcp'].values.tolist()
        #dems = readNetcdf(filedir)[0]['dem'].values.tolist()
        self.dockwidget.ICSalinitySealevelComboBox.clear()
        self.dockwidget.ICSalinitySealevelComboBox.addItems(time_steps)
        #self.dockwidget.ICSalinityRcpComboBox.addItems(rcps)
        #self.dockwidget.ICSalinityDemComboBox.addItems(dems)

    #   on change actions of the Head IC type combobox
    def icSalinityComboboxChange(self):
        #   the try except is here to avoid warning because self.nc_dataset doesnt exist yet.. 
        try:
            nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.initial_conditions_selected, 'temp_files', self.initial_conditions_selected + '_INPUT.nc')
            self.nc_dataset = readNetcdfSEAWATModelInput(nc_path)   
            self.ic_salinity_array = self.nc_dataset[13]
            self.x = self.nc_dataset[0]
            self.topo = self.nc_dataset[3]
        except AttributeError:
            pass        
        #   based on different options perform different tasks
        if self.dockwidget.ICSalinityComboBox.currentText() == 'Constant':
            self.dockwidget.ICSalinityDoubleSpinBox.setDisabled(False)
            self.dockwidget.selectICFileComboBox.setDisabled(True)
            self.dockwidget.loadICfileToModelViewerPushButton.setDisabled(True)
            self.dockwidget.ICSalinitySealevelComboBox.setDisabled(True)
            self.ic_salinity_array[~np.isnan(self.ic_salinity_array)] = self.dockwidget.ICSalinityDoubleSpinBox.value()
            self.dockwidget.ICSalinityRcpComboBox.setDisabled(True)
            self.dockwidget.ICSalinityDemComboBox.setDisabled(True)
            #   plot the salinity
            if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
                self.ic_plotWdg.plotSalinityArray(self.ic_salinity_array, self.topo, self.nc_dataset[0], self.nc_dataset[1]) 

        elif self.dockwidget.ICSalinityComboBox.currentText() == 'Split at coast':
            #   disable the spinbox for constant values
            self.dockwidget.ICSalinityDoubleSpinBox.setDisabled(True)
            self.dockwidget.selectICFileComboBox.setDisabled(True)
            self.dockwidget.loadICfileToModelViewerPushButton.setDisabled(True)
            self.dockwidget.ICSalinitySealevelComboBox.setDisabled(True)
            self.dockwidget.ICSalinityRcpComboBox.setDisabled(True)
            self.dockwidget.ICSalinityDemComboBox.setDisabled(True)
            for i in range(self.ic_salinity_array.shape[-1]):
                for j in range(self.ic_salinity_array.shape[0]):
                    if not math.isnan(self.ic_salinity_array[j, i]) and self.x[i] < 0:        
                        self.ic_salinity_array[j, i] = 0.
                    elif not math.isnan(self.ic_salinity_array[j, i]) and self.x[i] >= 0:
                        self.ic_salinity_array[j, i] = 35.
            #   plot the salinity
            if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
                self.ic_plotWdg.plotSalinityArray(self.ic_salinity_array, self.topo, self.nc_dataset[0], self.nc_dataset[1])  

        elif self.dockwidget.ICSalinityComboBox.currentText() == 'Interpolated':
            self.dockwidget.ICSalinityDoubleSpinBox.setDisabled(True)
            self.dockwidget.selectICFileComboBox.setDisabled(False)
            self.dockwidget.loadICfileToModelViewerPushButton.setDisabled(False)
            self.dockwidget.ICSalinitySealevelComboBox.setDisabled(False)  
            self.dockwidget.ICSalinityRcpComboBox.setDisabled(False)
            self.dockwidget.ICSalinityDemComboBox.setDisabled(False)
            
            #   populate the combobox with all files found in the folder with model results
            file_lst = [f for f in os.listdir(self.dockwidget.selectModelFiles.text()) if os.path.isfile(os.path.join(self.dockwidget.selectModelFiles.text(), f)) and\
                        os.path.join(os.path.join(self.dockwidget.selectModelFiles.text(), f)).endswith(".nc")]   
            #   clear the items first, otherwise the lists just ends up growing with each selection of 'Interpolated'
            self.dockwidget.selectICFileComboBox.clear()
            self.dockwidget.ICSalinityRcpComboBox.clear()
            self.dockwidget.ICSalinityDemComboBox.clear()
            self.dockwidget.selectICFileComboBox.addItems(file_lst)
            self.dockwidget.ICSalinityRcpComboBox.addItems(['26', '45', '85'])
            self.dockwidget.ICSalinityDemComboBox.addItems(['coastal', 'gebco', 'merit'])

            filedir = os.path.join(self.dockwidget.selectModelFiles.text(), self.dockwidget.selectICFileComboBox.currentText())
            #   read the netcdf file
            time_steps = readNetcdf(filedir)[0]['time'].values.tolist()
            time_steps = [str(i) for i in time_steps]
            self.dockwidget.ICSalinitySealevelComboBox.clear()
            self.dockwidget.ICSalinitySealevelComboBox.addItems(time_steps)
            #   based on selection of the file set the combobox with the time steps
            #self.dockwidget.selectICFileComboBox.currentTextChanged.connect(self.getIcFileTimestepsSealevel)   
            """
            nc_dataset = readNetcdfSEAWATModelInput(r'g:\_modelbuilder\swampy\data\test_model8\temp_files\test_model8_INPUT.nc')
            in_salinity_nc = readNetcdf(r'g:\Water_Nexus\_A4_models\_SLR_models_OUT_files\_avg_nc_files_MERGING\0016_SRM_14.nc') 
            in_salinity_arr = in_salinity_nc[0].sel(time = 0).sel(dem = 'coastal').sel(rcp = '45')['salinity'] 
            ic_salinity_array = interpolate_salinity_arr(in_salinity_arr, nc_dataset[13], nc_dataset[0], nc_dataset[1])
            """
            #self.ic_salinity_array = interpolate_salinity_arr(in_salinity_arr, self.ic_salinity_array, self.nc_dataset[0], self.nc_dataset[1])

    def icInterpolateSalinity(self):
        self.in_salinity_nc = readNetcdf(os.path.join(self.dockwidget.selectModelFiles.text(), self.dockwidget.selectICFileComboBox.currentText()))
        self.in_salinity_arr = self.in_salinity_nc[0].sel(time = int(self.dockwidget.ICSalinitySealevelComboBox.currentText())).sel(dem = self.dockwidget.ICSalinityDemComboBox.currentText()).sel(rcp = self.dockwidget.ICSalinityRcpComboBox.currentText())['salinity'] 
        try:
            nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.initial_conditions_selected, 'temp_files', self.initial_conditions_selected + '_INPUT.nc')
            self.nc_dataset = readNetcdfSEAWATModelInput(nc_path) 
            self.topo = self.nc_dataset[3]
        except AttributeError:
            pass  
        
        #self.ic_salinity_array = interpolate_salinity_arr(self.in_salinity_arr, self.nc_dataset[13], self.nc_dataset[0], self.nc_dataset[1])

        #   create a task outside the UI
        task_interpolate_salinity = QgsTask.fromFunction('Interpolate Initial salinity ', interpolate_salinity_arr_QgSTask, on_finished = interpolate_salinity_arr_QgSTask_completed, in_salinity = self.in_salinity_arr,\
                                                         out_salinity_arr = self.nc_dataset[13], x_cells = self.nc_dataset[0], y_cells = self.nc_dataset[1], out_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.initial_conditions_selected, 'temp_files'))
        self.ic_salinity_array = QgsApplication.taskManager().addTask(task_interpolate_salinity)
        QgsMessageLog.logMessage('Interpolate Initial salinity ')
    
        #   this will load the results but only after the task is completed
        while task_interpolate_salinity.status() not in [QgsTask.Complete, QgsTask.Terminated]:
            QCoreApplication.processEvents()
        while QgsApplication.taskManager().countActiveTasks() > 0:
            QCoreApplication.processEvents()

        self.ic_salinity_array = readNetcdf(os.path.join(self.dockwidget.outDirLineEdit.text(), self.initial_conditions_selected, 'temp_files', 'IC_salinity_interpolated.nc'))[0]['solute concentration'].values

        #   plot the salinity
        if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
            self.ic_plotWdg.plotSalinityArray(self.ic_salinity_array, self.topo, self.nc_dataset[0], self.nc_dataset[1]) 
        
        
    def addToModelViewer(self):
        #   if the model is already in the list dont add it again
        if self.dockwidget.selectICFileComboBox.currentText() in self.model.model_list:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Warning")
            msg.setInformativeText('This model is already loaded in and wont be loaded again.')
            msg.setWindowTitle("Warning")
            msg.exec_()                    
        else:
            self.model.model_list.append(self.dockwidget.selectICFileComboBox.currentText())
            self.model.layoutChanged.emit()
            #   load tha netcdf file, define the directory where netcdf files are stored
            #   first check if the file exists
            nc_path = os.path.join(self.dockwidget.selectModelFiles.text(), self.dockwidget.selectICFileComboBox.currentText())
            if os.path.isfile(nc_path):
                self.nc_dataset = readNetcdf(nc_path)
                self.updateSpinBoxes(self.nc_dataset[1], self.nc_dataset[2])
                self.timestep = 0
                self.plotWdg.plotConcProfile(self.nc_dataset[0], self.timestep, self.dockwidget.rcpComboBox.currentText(), self.dockwidget.demComboBox.currentText(),\
                                             self.dockwidget.xminSpinBox.value(), self.dockwidget.xmaxSpinBox.value(), self.dockwidget.yminSpinBox.value(), self.dockwidget.ymaxSpinBox.value())   
                #   set texts and values for the zoom and time slider
                self.dockwidget.ts_label.setText(str(0))
                self.dockwidget.ts_horizontalBar.setValue(35)
                #   set the initial values and steps for the sliders
            else:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Error")
                msg.setInformativeText('File  ' + nc_path + '  doesnt exist!')
                msg.setWindowTitle("Error")
                msg.exec_()                        

    #   save the array to the netcdf file 
    def safeICtoNetcdf(self):
        nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.initial_conditions_selected, 'temp_files', self.initial_conditions_selected + '_INPUT.nc')
        if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
            updateNetcdfICSalinityArray(nc_path, self.ic_salinity_array)            
        else:
            updateNetcdfICHeadsArray(nc_path, self.ic_head_array)    


    """  ------------------------------------------------------------ 
         Tools for the SEAWAT parameters tab                      """        
        
    #   saving SEAWAT parameter values into the numpy dictionary
    def onClickedSaveSEAWATParameters(self):
        #   define the name
        seawat_dict_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_SEAWAT_pckgs.npy')
        #   call the function 
        save_SEAWAT_pckg_dictionaries(seawat_dict_dir, self.dockwidget.laycbdSpinBox.value(), self.dockwidget.laytypSpinBox.value(), self.dockwidget.ipakcbSpinBox.value(), self.dockwidget.ghbIpakcbSpinBox.value(),\
                                      self.dockwidget.rchNrchopSpinBox.value(), self.dockwidget.rchConcDoubleSpinBox.value(), self.dockwidget.rchIpakcbSpinBox.value(), self.dockwidget.drnIpakcbSpinBox.value(),\
                                      self.dockwidget.ocTsSpinBox.value(), self.dockwidget.btnPorositySpinBox.value(), self.dockwidget.btnDt0SpinBox.value(), self.dockwidget.btnNprsSpinBox.value(),\
                                      self.dockwidget.btnTSfrequencySpinBox.value(), self.dockwidget.btnIfmtcnSpinBox.value(), self.dockwidget.btnChkmasComboBox.currentText(), self.dockwidget.btnNprmasSpinBox.value(),\
                                      self.dockwidget.btnNprobsSpinBox.value(), self.dockwidget.alDoubleSpinBox.value(), self.dockwidget.trptDoubleSpinBox.value(), self.dockwidget.trpvDoubleSpinBox.value(),\
                                      self.dockwidget.dspDmcoefLineEdit.text(), self.dockwidget.advMixelmComboBox.currentText(), self.dockwidget.mxpartSpinBox.value(), self.dockwidget.itrackSpinBox.value(),\
                                      self.dockwidget.wdDoubleSpinBox.value(), self.dockwidget.dcepsDoubleSpinBox.value(), self.dockwidget.nplaneSpinBox.value(), self.dockwidget.nplSpinBox.value(),\
                                      self.dockwidget.nphSpinBox.value(), self.dockwidget.npminSpinBox.value(), self.dockwidget.npmaxSpinBox.value(), self.dockwidget.interpSpinBox.value(),\
                                      self.dockwidget.nlsinkSpinBox.value(), self.dockwidget.npsinkSpinBox.value(), self.dockwidget.dchmocDoubleSpinBox.value(), self.dockwidget.iwtableSpinBox.value(),\
                                      self.dockwidget.denseminSpinBox.value(), self.dockwidget.densemaxSpinBox.value(), self.dockwidget.denserefSpinBox.value(), self.dockwidget.nplSpinBox.value(),\
                                      self.dockwidget.firstdtDoubleSpinBox.value(), self.dockwidget.iter1SpinBox.value(), self.dockwidget.mxiterSpinBox.value(), self.dockwidget.isolveSpinBox.value(),\
                                      self.dockwidget.ccloseDoubleSpinBox.value(), self.dockwidget.hcloseDoubleSpinBox.value(), self.dockwidget.rcloseDoubleSpinBox.value())

    #   test the model by writing SEAWAT packages for the first stress period and running the model for short time duration (e.g 1 day or 0.001 day)
    def onClickedTestSEAWATParameters(self):
        foldername =  os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'test_model')  
        swat_exe_dir = self.dockwidget.SEAWATLineEdit.text()
        NC_input_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_INPUT.nc')
        SP_tb_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_SP_input.csv')
        SEAWAT_params_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_SEAWAT_pckgs.npy')
        cs_points_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', 'cs_points.csv')
        rch_foldrer_dir = self.dockwidget.RchLineEdit.text()
        #   create the SEAWAT model object
        self.SEAWAT_model_obj_test = SEAWAT_model(foldername, swat_exe_dir, NC_input_dir, SP_tb_dir, SEAWAT_params_dir, cs_points_dir, rch_foldrer_dir)
        #   write the packages and run the model
        self.SEAWAT_model_obj_test.write_SEAWAT_packages(0, self.SEAWAT_model_obj_test.ic_head_arr, self.SEAWAT_model_obj_test.ic_salinity_arr, test = True)
        self.SEAWAT_model_obj_test.run_model()
        #   check if the packages were written succesfully and insert a row into the table in the SEAWAT tab
        pckg_success = self.SEAWAT_model_obj_test.check_convergence()
        pckg_success.insert(0, 'test')
        pckg_success = pckg_success + [self.SEAWAT_model_obj_test.converged , self.SEAWAT_model_obj_test.runtime]
        self.dockwidget.SEAWAT_packages_frame.add_row_testing(pckg_success)
        # print the listfile
        self.dockwidget.seawatTextEdit.clear()
        with open(os.path.join(foldername, self.SEAWAT_model_obj_test.name, self.SEAWAT_model_obj_test.name + '.list' ), "r") as file:
            for line in file:
                self.dockwidget.seawatTextEdit.append(line)
            
    #   Runs the whole SEAWAT model, looping through the stress periods and creating a merged output at the end into a single Netcdf file
    def onClickedRunSEAWATParameters(self):
        foldername =  os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'SEAWAT_model')  
        swat_exe_dir = self.dockwidget.SEAWATLineEdit.text()
        NC_input_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_INPUT.nc')
        SP_tb_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_SP_input.csv')
        SEAWAT_params_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_SEAWAT_pckgs.npy')
        cs_points_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', 'cs_points.csv')
        rch_foldrer_dir = self.dockwidget.RchLineEdit.text()
        
        #   loop through the stress period csv and run model for each period, extracting the SCONC and STRT arrays at the end of each stress period
        df_in = pd.read_csv(SP_tb_dir)# SP_tb_dir = r'g:\_modelbuilder\swampy\data\test_model\temp_files\test_model_SP_input.csv'
        for a in range(df_in[df_in.columns[0]].count()):
            #   create the SEAWAT model object
            self.SEAWAT_model_obj = SEAWAT_model(foldername, swat_exe_dir, NC_input_dir, SP_tb_dir, SEAWAT_params_dir, cs_points_dir, rch_foldrer_dir)
            #   write the packages and run the model, first check if its first SP, if yes then use the predefined initial conditions
            if a == 0:
                strt = self.SEAWAT_model_obj.ic_head_arr
                sconc = self.SEAWAT_model_obj.ic_salinity_arr
            self.SEAWAT_model_obj.write_SEAWAT_packages(a, strt, sconc, test = False)
            #   run the model and create the output
            self.SEAWAT_model_obj.run_model()
            self.SEAWAT_model_obj.create_model_output()
            sconc = self.SEAWAT_model_obj.next_sconc_arr
            strt = self.SEAWAT_model_obj.next_head_arr
            #   check if the packages were written succesfully and insert a row into the table in the SEAWAT tab
            pckg_success = self.SEAWAT_model_obj.check_convergence()
            pckg_success.insert(0, str(a))
            pckg_success = pckg_success + [self.SEAWAT_model_obj.converged , self.SEAWAT_model_obj.runtime]
            self.dockwidget.SEAWAT_packages_frame.add_row_testing(pckg_success)
        #   merge the netcdf files
        merge_SEAWAT_netcdf_files(foldername, cleanup = False)   
        #   read the netcdf and plot it
        nc_path = os.path.join(foldername, 'final_SEAWAT_output.nc')
        self.SEAWAT_nc_dataset = readNetcdf_SEAWAT(nc_path)
        #   set the sliding bar
        self.SEAWAT_timestep = self.SEAWAT_nc_dataset[-1][0]
        self.dockwidget.SEAWAT_ts_label.setText(str(self.SEAWAT_timestep))
        #   plot
        self.SEAWAT_plotWdg.plotConcProfile_SEAWAT_output(self.SEAWAT_nc_dataset[0], self.SEAWAT_timestep, self.SEAWAT_nc_dataset[1][0], self.SEAWAT_nc_dataset[1][-1],\
                                                          self.SEAWAT_nc_dataset[2][-1], self.SEAWAT_nc_dataset[2][0])            
        self.updateSpinBoxes_SEAWAT(self.SEAWAT_nc_dataset[1], self.SEAWAT_nc_dataset[2])
        #   set the slider max and min values
        self.dockwidget.SEAWAT_ts_horizontalBar.setMaximum(len(self.SEAWAT_nc_dataset[-1]))
        self.dockwidget.SEAWAT_ts_horizontalBar.setMinimum(1)
        self.dockwidget.SEAWAT_ts_horizontalBar.setValue(0)


        #SEAWAT_nc_dataset = readNetcdf_SEAWAT(r'g:\_modelbuilder\swampy\data\test_model6\SEAWAT_model\final_SEAWAT_output.nc')
        
        


    #   Runs the whole SEAWAT model as a separate QgsTask
    def onClickedRunSEAWATParameters_TASK(self):
        """
        foldername =  r'g:\_modelbuilder\swampy\data\test_model6\SEAWAT_model' 
        swat_exe_dir = self.dockwidget.SEAWATLineEdit.text()
        NC_input_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), 'test_model6', 'temp_files', 'test_model6' + '_INPUT.nc')
        SP_tb_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), 'test_model6', 'temp_files', 'test_model6' + '_SP_input.csv')
        SEAWAT_params_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), 'test_model6', 'temp_files', 'test_model6' + '_SEAWAT_pckgs.npy')
        cs_points_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), 'test_model6', 'temp_files', 'cs_points.csv')
        rch_foldrer_dir = self.dockwidget.RchLineEdit.text()
        """

        #   run the model and create the output, do it in the background so the UI is still responsive
        foldername =  os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'SEAWAT_model')  
        swat_exe_dir = self.dockwidget.SEAWATLineEdit.text()
        NC_input_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_INPUT.nc')
        SP_tb_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_SP_input.csv')
        SEAWAT_params_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_SEAWAT_pckgs.npy')
        cs_points_dir = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', 'cs_points.csv')
        rch_foldrer_dir = self.dockwidget.RchLineEdit.text()
        
        #   create a task outside the UI
        task_run_model = QgsTask.fromFunction('SEAWAT model run ', run_model_QgSTask, on_finished = run_model_QgSTask_completed, foldername = foldername, swat_exe_dir = swat_exe_dir,\
                                              NC_input_dir = NC_input_dir, SP_tb_dir = SP_tb_dir, SEAWAT_params_dir = SEAWAT_params_dir, cs_points_dir = cs_points_dir, rch_foldrer_dir = rch_foldrer_dir)
        QgsApplication.taskManager().addTask(task_run_model)
        QgsMessageLog.logMessage('SEAWAT model run')
    
        #   this will load the results but only after the task is completed
        while task_run_model.status() not in [QgsTask.Complete, QgsTask.Terminated]:
            QCoreApplication.processEvents()
        while QgsApplication.taskManager().countActiveTasks() > 0:
            QCoreApplication.processEvents()

        #   read the netcdf and plot it
        nc_path = os.path.join(foldername, 'final_SEAWAT_output.nc')
        self.SEAWAT_nc_dataset = readNetcdf_SEAWAT(nc_path)
        #   set the sliding bar
        self.SEAWAT_timestep = self.SEAWAT_nc_dataset[-1][0]
        self.dockwidget.SEAWAT_ts_label.setText(str(self.SEAWAT_timestep))
        #   plot
        self.SEAWAT_plotWdg.plotConcProfile_SEAWAT_output(self.SEAWAT_nc_dataset[0], self.SEAWAT_timestep, self.SEAWAT_nc_dataset[1][0], self.SEAWAT_nc_dataset[1][-1],\
                                                          self.SEAWAT_nc_dataset[2][-1], self.SEAWAT_nc_dataset[2][0])            
        self.updateSpinBoxes_SEAWAT(self.SEAWAT_nc_dataset[1], self.SEAWAT_nc_dataset[2])
        #   set the slider max and min values
        self.dockwidget.SEAWAT_ts_horizontalBar.setMaximum(len(self.SEAWAT_nc_dataset[-1]))
        self.dockwidget.SEAWAT_ts_horizontalBar.setMinimum(1)
        self.dockwidget.SEAWAT_ts_horizontalBar.setValue(0)
        self.addSEAWATModel_visualization(self.SEAWAT_parameters_selected)


    """  ------------------------------------------------------------ 
         Tools for the SEAWAT visualization tab                      """   

    #   add model to the 
    def plotSEAWAT(self):
        nc_path = r'g:\_modelbuilder\swampy\data\test_model42\SEAWAT_model\final_SEAWAT_output.nc'
        self.SEAWAT_nc_dataset = readNetcdf_SEAWAT(nc_path)
        #   set the sliding bar
        self.SEAWAT_timestep = self.SEAWAT_nc_dataset[-1][0]
        self.dockwidget.SEAWAT_ts_horizontalBar.setMaximum(len(self.SEAWAT_nc_dataset[-1]))
        self.dockwidget.SEAWAT_ts_horizontalBar.setMinimum(0)
        self.dockwidget.SEAWAT_ts_horizontalBar.setValue(0)
        self.dockwidget.SEAWAT_ts_label.setText(str(self.SEAWAT_timestep))
        self.updateSpinBoxes_SEAWAT(self.SEAWAT_nc_dataset[1], self.SEAWAT_nc_dataset[2])
        #   plot
        self.SEAWAT_plotWdg.plotConcProfile_SEAWAT_output(self.SEAWAT_nc_dataset[0], self.SEAWAT_timestep, self.SEAWAT_nc_dataset[1][0], self.SEAWAT_nc_dataset[1][-1],\
                                                          self.SEAWAT_nc_dataset[2][-1], self.SEAWAT_nc_dataset[2][0])             

    #   action to update the spinboxes with coordinates
    def updateSpinBoxes_SEAWAT(self, xcoord, ycoord):
        self.dockwidget.SEAWAT_xmaxSpinBox.setMinimum(xcoord[1])
        self.dockwidget.SEAWAT_xmaxSpinBox.setMaximum(xcoord[-1])
        self.dockwidget.SEAWAT_xmaxSpinBox.setValue(xcoord[-1])
        self.dockwidget.SEAWAT_xminSpinBox.setMinimum(xcoord[0])
        self.dockwidget.SEAWAT_xminSpinBox.setMaximum(xcoord[-2])
        self.dockwidget.SEAWAT_xminSpinBox.setValue(xcoord[0])        
        self.dockwidget.SEAWAT_ymaxSpinBox.setMinimum(ycoord[-2])
        self.dockwidget.SEAWAT_ymaxSpinBox.setMaximum(ycoord[0])            
        self.dockwidget.SEAWAT_ymaxSpinBox.setValue(ycoord[0])
        self.dockwidget.SEAWAT_yminSpinBox.setMaximum(ycoord[1])
        self.dockwidget.SEAWAT_yminSpinBox.setMinimum(ycoord[-1])        
        self.dockwidget.SEAWAT_yminSpinBox.setValue(ycoord[-1]) 

    #   action that plots a selected model from the listview
    def onClickedRow_SEAWAT(self, index = None):
        #   plot the selected profile 
        self.SEAWAT_model_vis_selected = str(self.model_SEAWAT_vis.data(index, Qt.DisplayRole))        
        nc_path = (self.dockwidget.outDirLineEdit.text(), self.SEAWAT_model_vis_selected, 'SEAWAT_model', 'final_SEAWAT_output.nc')
        self.SEAWAT_nc_dataset = readNetcdf_SEAWAT(nc_path)
        #   set the sliding bar
        self.SEAWAT_timestep = self.SEAWAT_nc_dataset[-1][0]
        self.dockwidget.SEAWAT_ts_label.setText(str(0))
        self.dockwidget.SEAWAT_ts_horizontalBar.setValue(self.SEAWAT_nc_dataset[-1].index(self.SEAWAT_timestep))
        #   plot
        self.SEAWAT_plotWdg.plotConcProfile_SEAWAT_output(self.SEAWAT_nc_dataset[0], self.SEAWAT_timestep, self.dockwidget.SEAWAT_xminSpinBox.value(), self.dockwidget.SEAWAT_xmaxSpinBox.value(),\
                                                          self.dockwidget.SEAWAT_yminSpinBox.value(), self.dockwidget.SEAWAT_ymaxSpinBox.value())    
        if self.dockwidget.SEAWAT_fixZoomCheckBox.isChecked() == True:
            pass
        else:
            self.updateSpinBoxes_SEAWAT(self.SEAWAT_nc_dataset[1], self.SEAWAT_nc_dataset[2])  

    #   on change actions of the spinboxes
    def zoomPlot_SEAWAT(self):
        self.SEAWAT_plotWdg.zoom(self.dockwidget.SEAWAT_xminSpinBox.value(), self.dockwidget.SEAWAT_xmaxSpinBox.value(), self.dockwidget.SEAWAT_yminSpinBox.value(), self.dockwidget.SEAWAT_ymaxSpinBox.value())  

    #   if clicked reset zoom to the full extent of the selected model
    def resetZoom_SEAWAT(self):
        self.SEAWAT_plotWdg.zoom(self.SEAWAT_nc_dataset[1][0], self.SEAWAT_nc_dataset[1][-1], self.SEAWAT_nc_dataset[2][-1], self.SEAWAT_nc_dataset[2][0])  
        self.updateSpinBoxes_SEAWAT(self.SEAWAT_nc_dataset[1], self.SEAWAT_nc_dataset[2])  
        
    #   define the function for the time slide bar, need to define a dictionary with values (1-45 paired with the time steps in NETCDF files)
    def changedValue_SEAWAT(self):
        #   define the list of timesteps
        ts_lst = self.SEAWAT_nc_dataset[-1]
        self.SEAWAT_timestep = ts_lst[self.dockwidget.SEAWAT_ts_horizontalBar.value() - 1]
        self.dockwidget.SEAWAT_ts_label.setText(str(self.SEAWAT_timestep))
        self.SEAWAT_plotWdg.plotConcProfile_SEAWAT_output(self.SEAWAT_nc_dataset[0], self.SEAWAT_timestep, self.dockwidget.SEAWAT_xminSpinBox.value(), self.dockwidget.SEAWAT_xmaxSpinBox.value(),\
                                                   self.dockwidget.SEAWAT_yminSpinBox.value(), self.dockwidget.SEAWAT_ymaxSpinBox.value()) 


          
    #--------------------------------------------------------------------------
    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = swampyDockWidget()

            #print "** STARTING swampy"
            #elf.dlg = swampyDockWidget()

            #   select directories for the input shapefiles and the folder with netcdf files with model results
            #self.dockwidget.selectCoastlineNodesButton.clicked.connect(self.select_coastline_nodes_file)
            self.dockwidget.selectCoastlineButton.clicked.connect(self.select_coastline_file)
            self.dockwidget.selectNetcdfButton.clicked.connect(self.select_model_nc_file)
            #   load the layers into the map
            self.dockwidget.loadCoastlineModels.clicked.connect(self.load_coastline_shapefile)
            
            #   buttons to save and load directories 
            self.dockwidget.setupSaveDirsButton.clicked.connect(self.save_dirs)
            self.dockwidget.setupLoadDirsButton.clicked.connect(self.load_dirs)

            #   define the zooming spinboxes 
            self.dockwidget.xminSpinBox.valueChanged.connect(self.zoomPlot)
            self.dockwidget.xmaxSpinBox.valueChanged.connect(self.zoomPlot)
            self.dockwidget.yminSpinBox.valueChanged.connect(self.zoomPlot)
            self.dockwidget.ymaxSpinBox.valueChanged.connect(self.zoomPlot)
            
            # Create the maptlotlib FigureCanvas object, which defines a single set of axes as self.axes.
            layout = self.dockwidget.frame_for_plot.layout()
            
            #self.plotWdg = ModelPlotCanvas.addPlotWidget(self, width = 12, height = 4, dpi = 300)
            
            self.plotWdg = ModelPlotCanvas(self, width = 12, height = 4, dpi = 300)
            layout.addWidget(self.plotWdg.canvas_to_print)
            self.toolbar = NavigationToolbar(self.plotWdg.canvas_to_print, self.dockwidget.mplToolbar)
            self.toolbar.zoom()
            
            #   define the slider
            self.dockwidget.ts_horizontalBar.valueChanged.connect(self.changedValue)
            self.dockwidget.rcpComboBox.currentTextChanged.connect(self.rcpDemChange)
            self.dockwidget.demComboBox.currentTextChanged.connect(self.rcpDemChange)

            #   create the list menu on the right side
            self.model = ModelListTable(model_list = [])
            self.dockwidget.listView.setModel(self.model)
            self.dockwidget.listView.clicked.connect(self.onClickedRow)
            #self.dockwidget.listView.selectionModel().currentChanged.connect(self.on_selectionChanged)
            self.dockwidget.addModelButton.clicked.connect(self.add)
            self.dockwidget.removeModelButton.clicked.connect(self.delete)
            self.dockwidget.zoomResetButton.clicked.connect(self.resetZoom)

            """     THE INPUT DATASET TAB     """
            #   try to load the directories from a previously defined python dictionary file
            self.dockwidget.SaveInputDirsPushButton.clicked.connect(self.save_dirs)
            self.dockwidget.LoadInputDirsPushButton.clicked.connect(self.load_dirs)
            #   the button "Load new" will always load new dataset to the combobox menu
            self.dockwidget.indta_loadDem.clicked.connect(self.inputDta_select_DEM)
            self.dockwidget.indta_loadCstFeatures.clicked.connect(self.inputDta_select_CstFeatures)
            self.dockwidget.indta_loadCstThk.clicked.connect(self.inputDta_select_CstThk)
            self.dockwidget.indta_loadUpperSedThk.clicked.connect(self.inputDta_select_UpperSedThk)
            self.dockwidget.indta_loadHkAqf.clicked.connect(self.inputDta_select_HkAqf)
            self.dockwidget.indta_loadHkAqt.clicked.connect(self.inputDta_select_HkAqt)
            self.dockwidget.indta_loadGeoHeterogeneity.clicked.connect(self.inputDta_select_GeoHeterogeneity)
            self.dockwidget.indta_loadRch.clicked.connect(self.inputDta_select_Rch)
            self.dockwidget.indta_loadSEAWAT.clicked.connect(self.inputDta_select_SEAWAT)
            self.dockwidget.indta_setOutputDir.clicked.connect(self.inputDta_select_output_dir)
            #   buttons that load individual datasets to map
            self.dockwidget.loadDEMToMapPushButton.clicked.connect(self.load_DEM_to_map)
            self.dockwidget.loadCstFeaturesToMapPushButton.clicked.connect(self.load_CstFeatures_to_map)
            self.dockwidget.loadCstThkToMapPushButton.clicked.connect(self.load_cst_thk_to_map)
            self.dockwidget.loadUppSedThkToMapPushButton.clicked.connect(self.load_upp_sed_thk_to_map)            
            self.dockwidget.loadHkAqfToMapPushButton.clicked.connect(self.load_hk_aqf_to_map)
            self.dockwidget.loadHkAqtToMapPushButton.clicked.connect(self.load_hk_aqt_to_map)
            self.dockwidget.loadGeoHeteroToMapPushButton.clicked.connect(self.load_geo_hetero_to_map)   
            #   loop through the folder with RCH files                 
            self.dockwidget.loadRCHToMapPushButton.clicked.connect(self.load_raster_layer_to_map_from_folder)                    

            """     THE CROSS-SECTION AND GRID GEOMETRY TAB     """
            #   setting up the cross-sectional model
            self.dockwidget.addInlandCoordinatesButton.clicked.connect(self.startCapturingInland)
            self.dockwidget.addOffshoreCoordinatesButton.clicked.connect(self.startCapturingOffshore)
            self.dockwidget.drawCsPushButton.clicked.connect(self.drawCS)
            self.dockwidget.add2DModelButton.clicked.connect(self.addModel)
            self.dockwidget.clenIBOUNDarrayPushButton.clicked.connect(self.cleanIBOUND)
            #   create menu with model names - to be updated into a table with checkmarks?
            self.model_CS = ModelListTable(model_list = [])
            ##   ----------------------------------------
            ##      make this into a table later on - with indicators to show if IBOUND, BC, IC are correct and defined
            self.dockwidget.modelTableOverview.setModel(self.model_CS)
            self.dockwidget.modelTableOverview.clicked.connect(self.onClickedRowCSModel)
            #self.dockwidget.removeModelButton.clicked.connect(self.delete)
            #self.dockwidget.zoomResetButton.clicked.connect(self.resetZoom)            
            #   create the plotting frame
            ibound_layout = self.dockwidget.modelGridPlotFrame.layout()
            self.ibound_plotWdg = IboundArrayPlotCanvas(self, width = 12, height = 4, dpi = 300)
            ibound_layout.addWidget(self.ibound_plotWdg.canvas_to_print)
            self.toolbar = NavigationToolbar(self.ibound_plotWdg.canvas_to_print, self.dockwidget.modelGridPlotMplToolbar)
            
            """     THE GEOLOGY SETUP TAB     """
            #   create the plotting frame
            geology_layout = self.dockwidget.geologyGridPlotFrame.layout()
            self.geology_plotWdg = GeologyArrayPlotCanvas(self, width = 12, height = 4, dpi = 300)
            geology_layout.addWidget(self.geology_plotWdg.canvas_to_print)
            self.toolbar = NavigationToolbar(self.geology_plotWdg.canvas_to_print, self.dockwidget.geologyGridPlotMplToolbar)
            self.dockwidget.sedFluxComboBox.addItems(['low', 'medium', 'high'])
            #   create menu with model names - to be updated into a table with checkmarks?
            self.model_geology = ModelListTable(model_list = [])
            ##   ----------------------------------------
            ##      make this into a table later on - with indicators to show if IBOUND, BC, IC are correct and defined
            self.dockwidget.geologyTableOverview.setModel(self.model_geology)
            self.dockwidget.geologyTableOverview.clicked.connect(self.onClickedRowGeologyModel)
            self.dockwidget.randomizeGeologyPushButton.clicked.connect(self.randomizeGeologyScenario)
            self.dockwidget.plotGeologyPushButton.clicked.connect(self.plotGeologyProfile)                
            self.dockwidget.saveGeologyButton.clicked.connect(self.saveGeologyProfile)                
            self.dockwidget.loadGeoHeterogeneityValuesPushButton.clicked.connect(self.getGeoHeterogeneityVals)
    
            """     STRESS PERIODS AND BOUNDARY CONDITIONS TABLE     """
            sp_layout = self.dockwidget.SP_frame.layout()
            self.load_RCH_files_from_folder()
            self.dockwidget.SP_frame = BC_inputTable([])
            sp_layout.addWidget(self.dockwidget.SP_frame)
            #   create menu with model names - to be updated into a table with checkmarks?
            self.model_stress_periods = ModelListTable(model_list = [])            
            self.dockwidget.stressPeriodsTableOverview.setModel(self.model_stress_periods)
            self.dockwidget.stressPeriodsTableOverview.clicked.connect(self.onClickedRowStressPeriodModel)
            self.dockwidget.AddSpPushButton.clicked.connect(self.dockwidget.SP_frame._addrow)
            self.dockwidget.CopySpPushButton.clicked.connect(self.dockwidget.SP_frame._copyrow)
            self.dockwidget.delSpPushButton.clicked.connect(self.dockwidget.SP_frame._removerow)
            self.dockwidget.saveSpTablePushButton.clicked.connect(self.saveSpTableToCsv)

            """     THE INITIAL CONDITION TAB     """
            #   create the plotting frame
            ic_layout = self.dockwidget.IC_frame.layout()
            self.ic_plotWdg = ICArrayPlotCanvas(self, width = 12, height = 4, dpi = 300)
            ic_layout.addWidget(self.ic_plotWdg.canvas_to_print)
            self.toolbar = NavigationToolbar(self.ic_plotWdg.canvas_to_print, self.dockwidget.ICGridPlotMplToolbar)
            #   create menu with model names - to be updated into a table with checkmarks?
            self.model_IC = ModelListTable(model_list = [])
            self.dockwidget.initialConditionsTableOverview.setModel(self.model_IC)
            self.dockwidget.initialConditionsTableOverview.clicked.connect(self.onClickedRowInitialConditionsModel)
            self.dockwidget.ICPlotComboBox.currentTextChanged.connect(self.icComboboxChange)
            #   add items to all the comboboxes
            self.dockwidget.ICHeadComboBox.addItems(['Constant', 'Topography based'])
            self.dockwidget.ICSalinityComboBox.addItems(['Constant', 'Split at coast', 'Interpolated'])
            #self.dockwidget.ICSalinitySealevelComboBox.addItems(['low', 'medium', 'high'])
            self.dockwidget.ICPlotComboBox.addItems(['Head elevation', 'Salinity'])
            self.dockwidget.ICHeadComboBox.currentTextChanged.connect(self.icHeadComboboxChange)
            self.dockwidget.ICSalinityComboBox.currentTextChanged.connect(self.icSalinityComboboxChange)
            self.dockwidget.interpolateICSalinityPushButton.clicked.connect(self.icInterpolateSalinity)
            self.dockwidget.loadICfileToModelViewerPushButton.clicked.connect(self.addToModelViewer)
            self.dockwidget.saveICsPpushButton.clicked.connect(self.safeICtoNetcdf)

            """     THE SEAWAT PACKAGES AND RUN MODEL TAB     """
            #   create menu with model names - to be updated into a table with checkmarks?
            self.model_SEAWAT = ModelListTable(model_list = [])
            self.dockwidget.seawatTableOverview.setModel(self.model_SEAWAT)
            self.dockwidget.seawatTableOverview.clicked.connect(self.onClickedRowSEAWATModel)
            #   setup the table widget where the cells will show if the packages are written correctly
            seawat_params_layout = self.dockwidget.SEAWAT_packages_frame.layout()
            self.dockwidget.SEAWAT_packages_frame = SEAWAT_parameters_testTable()
            seawat_params_layout.addWidget(self.dockwidget.SEAWAT_packages_frame)

            #   button to save the changed seawat parameters, test run, and run the whole model
            self.dockwidget.SaveSEAWATpckgPushButton.clicked.connect(self.onClickedSaveSEAWATParameters)
            self.dockwidget.TestRunPushButton.clicked.connect(self.onClickedTestSEAWATParameters)
            #self.dockwidget.RunModelPushButton.clicked.connect(self.onClickedRunSEAWATParameters)
            self.dockwidget.RunModelPushButton.clicked.connect(self.onClickedRunSEAWATParameters_TASK)

            """     THE SEAWAT MODEL VISUALIZATION TAB     """
            #   create menu with model names - to be updated into a table with checkmarks?
            self.model_SEAWAT_vis = ModelListTable(model_list = [])
            self.dockwidget.SEAWAT_vis_listView.setModel(self.model_SEAWAT_vis)
            self.dockwidget.SEAWAT_vis_listView.clicked.connect(self.onClickedRow_SEAWAT)
            #   define the zooming spinboxes 
            self.dockwidget.SEAWAT_xminSpinBox.valueChanged.connect(self.zoomPlot_SEAWAT)
            self.dockwidget.SEAWAT_xmaxSpinBox.valueChanged.connect(self.zoomPlot_SEAWAT)
            self.dockwidget.SEAWAT_yminSpinBox.valueChanged.connect(self.zoomPlot_SEAWAT)
            self.dockwidget.SEAWAT_ymaxSpinBox.valueChanged.connect(self.zoomPlot_SEAWAT)
            # Create the maptlotlib FigureCanvas object, which defines a single set of axes as self.axes.
            layout = self.dockwidget.SEAWAT_frame_for_plot.layout()
            self.SEAWAT_plotWdg = ModelPlotCanvas(self, width = 12, height = 4, dpi = 300)
            layout.addWidget(self.SEAWAT_plotWdg.canvas_to_print)
            self.SEAWAT_toolbar = NavigationToolbar(self.SEAWAT_plotWdg.canvas_to_print, self.dockwidget.SEAWAT_mplToolbar)
            self.SEAWAT_toolbar.zoom()
            #   define the slider
            self.dockwidget.SEAWAT_ts_horizontalBar.valueChanged.connect(self.changedValue_SEAWAT)
            self.dockwidget.SEAWAT_zoomResetButton.clicked.connect(self.resetZoom_SEAWAT)
            #self.dockwidget.pushButton.clicked.connect(self.plotSEAWAT)

            #   setting up the geology for the cross-sectional models

            self.dockwidget.addInlandCoordinatesButton.clicked.connect(self.startCapturingInland)
            self.dockwidget.addOffshoreCoordinatesButton.clicked.connect(self.startCapturingOffshore)
            self.dockwidget.drawCsPushButton.clicked.connect(self.drawCS)
            self.dockwidget.add2DModelButton.clicked.connect(self.addModel)

            ##   ----------------------------------------
            ##      make this into a table later on - with indicators to show if IBOUND, BC, IC are correct and defined
            self.dockwidget.modelTableOverview.setModel(self.model_CS)
            self.dockwidget.modelTableOverview.clicked.connect(self.onClickedRowSEAWATModel)
            #self.dockwidget.removeModelButton.clicked.connect(self.delete)
            #self.dockwidget.zoomResetButton.clicked.connect(self.resetZoom)            


            
            #self.dockwidget.modelTableOverview.clicked.connect(self.onClickedRow)
            #self.dockwidget.addModelButton.clicked.connect(self.add)
            #self.dockwidget.removeModelButton.clicked.connect(self.delete)
            #self.dockwidget.zoomResetButton.clicked.connect(self.resetZoom)


            
            #self.dockwidget.inlExtSpinBox.valueChanged.connect(self.changeExtentCS)
            #self.dockwidget.offExtSpinBox.valueChanged.connect(self.changeExtentCS)

            #layout = QVBoxLayout()
            #layout.addWidget(self.toolbar)
            #layout = self.dockwidget.frame_for_plot.layout()
            #sc = ModelPlotCanvas(self, width = 12, height = 4, dpi = 300)
            #sc.axes.plot([0, 1, 2, 3, 4], [10, 1, 20, 3, 40])
            #layout.setCentralWidget(sc)
            
            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            self.iface.addDockWidget(Qt.BottomDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

    #   define the tool to create the inland point
    def startCapturingInland(self):
        self.mapTool = CoordTool(self.iface.mapCanvas())
        self.mapTool.mouseMoved.connect(self.mouseMovedInland)
        self.mapTool.mouseClicked.connect(self.mouseClickedInland)
        self.iface.mapCanvas().setMapTool(self.mapTool)
    def mouseMovedInland(self, point: QgsPointXY):
        self.updateInland(point)
    def updateInland(self, point: QgsPointXY):
        self.dockwidget.xInlandCoord.setText(str(round(point.x(), 8)))
        self.dockwidget.yInlandCoord.setText(str(round(point.y(), 8)))
    def mouseClickedInland(self, point: QgsPointXY):
        self.updateInland(point)
        self.iface.mapCanvas().unsetMapTool(self.mapTool)
    
    #   do the same for offshore
    def startCapturingOffshore(self):
        self.mapTool = CoordTool(self.iface.mapCanvas())
        self.mapTool.mouseMoved.connect(self.mouseMovedOffshore)
        self.mapTool.mouseClicked.connect(self.mouseClickedOffshore)
        self.iface.mapCanvas().setMapTool(self.mapTool)
    def mouseMovedOffshore(self, point: QgsPointXY):
        self.updateOffshore(point)
    def updateOffshore(self, point: QgsPointXY):
        self.dockwidget.xOffshoreCoord.setText(str(round(point.x(), 8)))
        self.dockwidget.yOffshoreCoord.setText(str(round(point.y(), 8)))
    def mouseClickedOffshore(self, point: QgsPointXY):
        self.updateOffshore(point)
        self.iface.mapCanvas().unsetMapTool(self.mapTool)
        
    #   action that will draw a cross-section polyline on the canvas
    def drawCS(self):
        #   if the perpendicular checkbox is checked we have to recalculate the position of the 
        #   inland and offshore points based on the intersection with the coastline
        if self.dockwidget.perpToCoastCheckBox.isChecked():
            perp_bool = True
        else:
            perp_bool = False
        #   proceed with calculating and drawing the cross-section
        self.mapTool = CoordTool(self.iface.mapCanvas())
        self.iface.mapCanvas().setMapTool(self.mapTool)
        self.mapTool.drawCrossSection(self.dockwidget.xInlandCoord.text(), self.dockwidget.yInlandCoord.text(),\
                                      self.dockwidget.xOffshoreCoord.text(), self.dockwidget.yOffshoreCoord.text(),\
                                      self.dockwidget.CstFeaturesLineEdit.text(), self.dockwidget.CstFeaturesLineEdit.text(),\
                                      self.dockwidget.modelNameLineEdit.text(),\
                                      self.dockwidget.outDirLineEdit.text(), self.dockwidget.colWidthSpinBox.value() * 1000.,
                                      self.dockwidget.layThkSpinBox.value() * 1000, perp_bool) 
        #   update the extent and distance
        self.dockwidget.xInlandCoord.setText(str(round(self.mapTool.inl_wgs_x, 8)))
        self.dockwidget.yInlandCoord.setText(str(round(self.mapTool.inl_wgs_y, 8))) 
        self.dockwidget.xOffshoreCoord.setText(str(round(self.mapTool.off_wgs_x, 8)))
        self.dockwidget.yOffshoreCoord.setText(str(round(self.mapTool.off_wgs_y, 8)))
        #   make sure the inland extend is always negative
        #if self.mapTool.inl_ext > 0:
        #    self.mapTool.inl_ext = -1 * self.mapTool.inl_ext
        self.updateSpinBox(self.mapTool.inl_ext, self.mapTool.off_ext)
        #   read in the coastal thickness from closest point to the cross-section, search in radius of 50km
        self.get_cst_thk = self.mapTool.getClosestCstThk(self.dockwidget.CstThkLineEdit.text())
        self.dockwidget.cstThkSpinBox.setValue(self.mapTool.ate_val)
        
        #self.iface.mapCanvas().unsetMapTool(self.mapTool)

    """  ------------------------------------------------------------ 
         Tools for the all the model lists                        """

    #   Add model to the listview, no need to plot the model because it is plotted during the creating of the model input files
    def addCSModel(self, name):
        if name in self.model_CS.model_list:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Warning")
            msg.setInformativeText('This model is already loaded in and wont be loaded again.')
            msg.setWindowTitle("Warning")
            msg.exec_()                    
        else:
            self.model_CS.model_list.append(name)
            self.model_CS.layoutChanged.emit()

    #   Add model to the listview, no need to plot the model because it is plotted during the creating of the model input files
    def addGeologyModel(self, name):
        if name in self.model_geology.model_list:
            pass                
        else:
            self.model_geology.model_list.append(name)
            self.model_geology.layoutChanged.emit()

    #   Add model to the listview, no need to plot the model because it is plotted during the creating of the model input files
    def addStressPeriodsModel(self, name):
        if name in self.model_stress_periods.model_list:
            pass                
        else:
            self.model_stress_periods.model_list.append(name)
            self.model_stress_periods.layoutChanged.emit()

    #   Add model to the listview, no need to plot the model because it is plotted during the creating of the model input files
    def addIinitalConditionsModel(self, name):
        if name in self.model_IC.model_list:
            pass                
        else:
            self.model_IC.model_list.append(name)
            self.model_IC.layoutChanged.emit()

    #   Add model to the listview, no need to plot the model because it is plotted during the creating of the model input files
    def addSEAWATModel(self, name):
        if name in self.model_SEAWAT.model_list:
            pass                
        else:
            self.model_SEAWAT.model_list.append(name)
            self.model_SEAWAT.layoutChanged.emit()

    #   Add model to the listview, no need to plot the model because it is plotted during the creating of the model input files
    def addSEAWATModel_visualization(self, name):
        if name in self.model_SEAWAT_vis.model_list:
            pass                
        else:
            self.model_SEAWAT_vis.model_list.append(name)
            self.model_SEAWAT_vis.layoutChanged.emit()

    #   set all the plots/tables/parameter value tabs to match the selected SEAWAT model
    def setAllFromSelectedModel(self):
        #   open the NETCDF file and plot the ibound array
        nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.CS_model_selected, 'temp_files', self.CS_model_selected+ '_INPUT.nc')
        self.nc_dataset = readNetcdfSEAWATModelInput(nc_path)        
        self.ibound_array = self.nc_dataset[2]
        self.cont_shlf_edge = self.nc_dataset[11]
        self.x_lst = self.nc_dataset[0]
        self.y_lst = self.nc_dataset[1]
        self.top_elev = self.nc_dataset[3]
        self.bot_elev = self.nc_dataset[4]
        self.x_shlf = self.nc_dataset[9][1]
        self.ibound_plotWdg.plotIBOUNDarray(self.nc_dataset[2], self.nc_dataset[3], self.nc_dataset[4], self.nc_dataset[7], self.nc_dataset[8],\
                                            self.nc_dataset[9], self.nc_dataset[10], self.nc_dataset[0], self.nc_dataset[1])        
        #   plot the IC array based on combobox selection
        if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
            self.ic_plotWdg.plotSalinityArray(self.nc_dataset[13], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        else:
            self.ic_plotWdg.plotHeadElevationArray(self.nc_dataset[12], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        #   populate the various fields with the values from the dictionary
        dict_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', self.geology_model_selected + '_geo_dict.npy')
        if os.path.exists(dict_path):
            dir_dict_in = np.load(dict_path, allow_pickle = True)            
            self.dockwidget.randomScenarioSpinBox.setValue(dir_dict_in.item()['rand_seed_in'])
            self.dockwidget.aqfNSpinBox.setValue(dir_dict_in.item()['n_aqf_aqt_lrs'])
            self.dockwidget.pfactSpinBox.setValue(dir_dict_in.item()['p_fact'])
            self.dockwidget.sandPctSpinBox.setValue(dir_dict_in.item()['sand_pct'])
            self.dockwidget.mudPctSpinBox.setValue(dir_dict_in.item()['mud_pct'])
            self.dockwidget.erosionFactorSpinBox.setValue(dir_dict_in.item()['erosion_fact'])            
            self.dockwidget.shelfClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_shelf_thk'])
            self.dockwidget.slopeClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_slope_thk'])
            self.dockwidget.inlandClayStartSpinBox.setValue(dir_dict_in.item()['off_lay_start'])
            self.dockwidget.hkAqfMeanSpinBox.setValue(dir_dict_in.item()['hk_aqf_mean'])
            self.dockwidget.hkAqfStdevSpinBox.setValue(dir_dict_in.item()['hk_aqf_std'])
            self.dockwidget.hkAqtMeanSpinBox.setValue(dir_dict_in.item()['hk_aqt_mean'])
            self.dockwidget.hkAqtStdevSpinBox.setValue(dir_dict_in.item()['hk_aqt_std'])
            self.dockwidget.hkClayMeanSpinBox.setValue(dir_dict_in.item()['hk_clay_mean'])
            self.dockwidget.hkClayStdevSpinBox.setValue(dir_dict_in.item()['hk_clay_std'])
            index = self.dockwidget.sedFluxComboBox.findText(dir_dict_in.item()['sed_flux'], Qt.MatchFixedString)
            if index >= 0:
                 self.dockwidget.sedFluxComboBox.setCurrentIndex(index)  
        self.geology_plotWdg.plotGeologyArray(self.nc_dataset[5], self.nc_dataset[3], self.nc_dataset[0], self.nc_dataset[1])                
        self.new_hk_arr = self.nc_dataset[5]
        #   set the SP table to match the selected SEAWAT model
        csv_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.stress_periods_selected, 'temp_files', self.stress_periods_selected + '_SP_input.csv')
        self.dockwidget.SP_frame._addrow_from_csv(csv_path, self.rch_files_lst)   
        #   read the numpy dictionary and set all the SEAWAT parameter values to match the selected SEAWAT model
        seawat_dict_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.SEAWAT_parameters_selected, 'temp_files', self.SEAWAT_parameters_selected + '_SEAWAT_pckgs.npy')
        if os.path.exists(seawat_dict_path):
            dir_dict_in = np.load(seawat_dict_path, allow_pickle = True)  
            self.dockwidget.laycbdSpinBox.setValue(dir_dict_in.item()['DIS_laycbd'])
            self.dockwidget.laytypSpinBox.setValue(dir_dict_in.item()['LPF_laytyp'])
            self.dockwidget.ipakcbSpinBox.setValue(dir_dict_in.item()['LPF_ipakcb'])
            self.dockwidget.ghbIpakcbSpinBox.setValue(dir_dict_in.item()['GHB_CHB_ipakcb'])
            self.dockwidget.rchNrchopSpinBox.setValue(dir_dict_in.item()['RCH_nrchop'])
            self.dockwidget.rchConcDoubleSpinBox.setValue(dir_dict_in.item()['RCH_conc'])            
            self.dockwidget.rchIpakcbSpinBox.setValue(dir_dict_in.item()['RCH_ipakcb'])
            self.dockwidget.drnIpakcbSpinBox.setValue(dir_dict_in.item()['DRN_ipakcb'])
            self.dockwidget.ocTsSpinBox.setValue(dir_dict_in.item()['OC_ts_freq'])
            self.dockwidget.btnPorositySpinBox.setValue(dir_dict_in.item()['BTN_porosity'])
            self.dockwidget.btnDt0SpinBox.setValue(dir_dict_in.item()['BTN_dt0'])
            self.dockwidget.btnNprsSpinBox.setValue(dir_dict_in.item()['BTN_nprs'])
            self.dockwidget.btnTSfrequencySpinBox.setValue(dir_dict_in.item()['BTN_ts_freq'])
            self.dockwidget.btnIfmtcnSpinBox.setValue(dir_dict_in.item()['BTN_ifmtcn'])           
            self.dockwidget.btnNprmasSpinBox.setValue(dir_dict_in.item()['BTN_nprmas'])
            self.dockwidget.btnNprobsSpinBox.setValue(dir_dict_in.item()['BTN_nprobs'])
            self.dockwidget.alDoubleSpinBox.setValue(dir_dict_in.item()['DSP_al'])
            self.dockwidget.trptDoubleSpinBox.setValue(dir_dict_in.item()['DSP_trpt'])
            self.dockwidget.trpvDoubleSpinBox.setValue(dir_dict_in.item()['DSP_trpv'])
            self.dockwidget.mxpartSpinBox.setValue(dir_dict_in.item()['ADV_mxpart'])
            self.dockwidget.itrackSpinBox.setValue(dir_dict_in.item()['ADV_itrack'])
            self.dockwidget.wdDoubleSpinBox.setValue(dir_dict_in.item()['ADV_wd'])
            self.dockwidget.dcepsDoubleSpinBox.setValue(dir_dict_in.item()['ADV_dceps'])
            self.dockwidget.nplaneSpinBox.setValue(dir_dict_in.item()['ADV_nplane'])
            self.dockwidget.nplSpinBox.setValue(dir_dict_in.item()['ADV_npl'])
            self.dockwidget.nphSpinBox.setValue(dir_dict_in.item()['ADV_nph'])
            self.dockwidget.npminSpinBox.setValue(dir_dict_in.item()['ADV_npmin'])
            self.dockwidget.npmaxSpinBox.setValue(dir_dict_in.item()['ADV_npmax'])
            self.dockwidget.interpSpinBox.setValue(dir_dict_in.item()['ADV_interp'])
            self.dockwidget.nlsinkSpinBox.setValue(dir_dict_in.item()['ADV_nlsink'])
            self.dockwidget.npsinkSpinBox.setValue(dir_dict_in.item()['ADV_npsink'])            
            self.dockwidget.dchmocDoubleSpinBox.setValue(dir_dict_in.item()['ADV_dchmoc'])
            self.dockwidget.iwtableSpinBox.setValue(dir_dict_in.item()['VDF_iwtable'])
            self.dockwidget.denseminSpinBox.setValue(dir_dict_in.item()['VDF_densemin'])
            self.dockwidget.densemaxSpinBox.setValue(dir_dict_in.item()['VDF_densemax'])
            self.dockwidget.denserefSpinBox.setValue(dir_dict_in.item()['VDF_denseref'])
            self.dockwidget.denseslpDoubleSpinBox.setValue(dir_dict_in.item()['VDF_denseslp'])
            self.dockwidget.firstdtDoubleSpinBox.setValue(dir_dict_in.item()['VDF_firstdt'])
            self.dockwidget.iter1SpinBox.setValue(dir_dict_in.item()['GCG_iter1'])
            self.dockwidget.mxiterSpinBox.setValue(dir_dict_in.item()['GCG_mxiter'])
            self.dockwidget.isolveSpinBox.setValue(dir_dict_in.item()['GCG_isolve'])
            self.dockwidget.ccloseDoubleSpinBox.setValue(dir_dict_in.item()['GCG_cclose'])
            self.dockwidget.hcloseDoubleSpinBox.setValue(dir_dict_in.item()['PCG_hclose'])
            self.dockwidget.rcloseDoubleSpinBox.setValue(dir_dict_in.item()['PCG_rclose'])
            self.dockwidget.dspDmcoefLineEdit.setText(str(dir_dict_in.item()['DSP_dmcoef']))     
            index = self.dockwidget.advMixelmComboBox.findText(str(dir_dict_in.item()['ADV_mixelm']), Qt.MatchFixedString)
            if index >= 0:
                 self.dockwidget.advMixelmComboBox.setCurrentIndex(index)  
            index = self.dockwidget.btnChkmasComboBox.findText(str(dir_dict_in.item()['BTN_chkmas']), Qt.MatchFixedString)
            if index >= 0:
                 self.dockwidget.btnChkmasComboBox.setCurrentIndex(index)  
        
    #   action that plots a selected model from the listview
    def onClickedRowCSModel(self, index = None):
        #   set all the model selections to match the index and show plots/tables/parameters for selected SEAWAT model    
        self.CS_model_selected = str(self.model_CS.data(index, Qt.DisplayRole))
        self.geology_model_selected = str(self.model_geology.data(index, Qt.DisplayRole))
        self.stress_periods_selected = str(self.model_stress_periods.data(index, Qt.DisplayRole))
        self.initial_conditions_selected = str(self.model_IC.data(index, Qt.DisplayRole))
        self.SEAWAT_parameters_selected = str(self.model_SEAWAT.data(index, Qt.DisplayRole))
        self.setAllFromSelectedModel()
        
        """
        nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.CS_model_selected, 'temp_files', self.CS_model_selected+ '_INPUT.nc')
        self.nc_dataset = readNetcdfSEAWATModelInput(nc_path)        
        self.ibound_array = self.nc_dataset[2]
        self.cont_shlf_edge = self.nc_dataset[11]
        self.x_lst = self.nc_dataset[0]
        self.y_lst = self.nc_dataset[1]
        self.top_elev = self.nc_dataset[3]
        self.bot_elev = self.nc_dataset[4]
        self.x_shlf = self.nc_dataset[9][1]
        self.ibound_plotWdg.plotIBOUNDarray(self.nc_dataset[2], self.nc_dataset[3], self.nc_dataset[4], self.nc_dataset[7], self.nc_dataset[8],\
                                            self.nc_dataset[9], self.nc_dataset[10], self.nc_dataset[0], self.nc_dataset[1])
        #   plot the IC array based on combobox selection
        if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
            self.ic_plotWdg.plotSalinityArray(self.nc_dataset[13], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        else:
            self.ic_plotWdg.plotHeadElevationArray(self.nc_dataset[12], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                

        #   populate the various fields with the values from the dictionary
        dict_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', self.geology_model_selected + '_geo_dict.npy')
        if os.path.exists(dict_path):
            dir_dict_in = np.load(dict_path, allow_pickle = True)            
            self.dockwidget.randomScenarioSpinBox.setValue(dir_dict_in.item()['rand_seed_in'])
            self.dockwidget.aqfNSpinBox.setValue(dir_dict_in.item()['n_aqf_aqt_lrs'])
            self.dockwidget.pfactSpinBox.setValue(dir_dict_in.item()['p_fact'])
            self.dockwidget.sandPctSpinBox.setValue(dir_dict_in.item()['sand_pct'])
            self.dockwidget.mudPctSpinBox.setValue(dir_dict_in.item()['mud_pct'])
            self.dockwidget.erosionFactorSpinBox.setValue(dir_dict_in.item()['erosion_fact'])            
            self.dockwidget.shelfClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_shelf_thk'])
            self.dockwidget.slopeClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_slope_thk'])
            self.dockwidget.inlandClayStartSpinBox.setValue(dir_dict_in.item()['off_lay_start'])
            self.dockwidget.hkAqfMeanSpinBox.setValue(dir_dict_in.item()['hk_aqf_mean'])
            self.dockwidget.hkAqfStdevSpinBox.setValue(dir_dict_in.item()['hk_aqf_std'])
            self.dockwidget.hkAqtMeanSpinBox.setValue(dir_dict_in.item()['hk_aqt_mean'])
            self.dockwidget.hkAqtStdevSpinBox.setValue(dir_dict_in.item()['hk_aqt_std'])
            self.dockwidget.hkClayMeanSpinBox.setValue(dir_dict_in.item()['hk_clay_mean'])
            self.dockwidget.hkClayStdevSpinBox.setValue(dir_dict_in.item()['hk_clay_std'])
            index = self.dockwidget.sedFluxComboBox.findText(dir_dict_in.item()['sed_flux'], Qt.MatchFixedString)
            if index >= 0:
                 self.dockwidget.sedFluxComboBox.setCurrentIndex(index)  
        """
        
    #   action that plots a selected geology from the listview
    def onClickedRowGeologyModel(self, index = None):
        #   plot the selected profile 
        self.CS_model_selected = str(self.model_CS.data(index, Qt.DisplayRole))
        self.geology_model_selected = str(self.model_geology.data(index, Qt.DisplayRole))
        self.stress_periods_selected = str(self.model_stress_periods.data(index, Qt.DisplayRole))
        self.initial_conditions_selected = str(self.model_IC.data(index, Qt.DisplayRole))
        self.SEAWAT_parameters_selected = str(self.model_SEAWAT.data(index, Qt.DisplayRole))
        self.setAllFromSelectedModel()
        """
        nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', self.geology_model_selected + '_INPUT.nc')
        self.nc_dataset = readNetcdfSEAWATModelInput(nc_path)        
        #   plot the IBOUND and geology arrays
        self.ibound_plotWdg.plotIBOUNDarray(self.nc_dataset[2], self.nc_dataset[3], self.nc_dataset[4], self.nc_dataset[7], self.nc_dataset[8],\
                                            self.nc_dataset[9], self.nc_dataset[10], self.nc_dataset[0], self.nc_dataset[1])
        self.geology_plotWdg.plotGeologyArray(self.nc_dataset[5], self.nc_dataset[3], self.nc_dataset[0], self.nc_dataset[1])                
        self.new_hk_arr = self.nc_dataset[5]

        #   populate the various fields with the values from the dictionary
        dict_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', self.geology_model_selected + '_geo_dict.npy')
        if os.path.exists(dict_path):
            dir_dict_in = np.load(dict_path, allow_pickle = True)            
            self.dockwidget.randomScenarioSpinBox.setValue(dir_dict_in.item()['rand_seed_in'])
            self.dockwidget.aqfNSpinBox.setValue(dir_dict_in.item()['n_aqf_aqt_lrs'])
            self.dockwidget.pfactSpinBox.setValue(dir_dict_in.item()['p_fact'])
            self.dockwidget.sandPctSpinBox.setValue(dir_dict_in.item()['sand_pct'])
            self.dockwidget.mudPctSpinBox.setValue(dir_dict_in.item()['mud_pct'])
            self.dockwidget.erosionFactorSpinBox.setValue(dir_dict_in.item()['erosion_fact'])            
            self.dockwidget.shelfClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_shelf_thk'])
            self.dockwidget.slopeClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_slope_thk'])
            self.dockwidget.inlandClayStartSpinBox.setValue(dir_dict_in.item()['off_lay_start'])
            self.dockwidget.hkAqfMeanSpinBox.setValue(dir_dict_in.item()['hk_aqf_mean'])
            self.dockwidget.hkAqfStdevSpinBox.setValue(dir_dict_in.item()['hk_aqf_std'])
            self.dockwidget.hkAqtMeanSpinBox.setValue(dir_dict_in.item()['hk_aqt_mean'])
            self.dockwidget.hkAqtStdevSpinBox.setValue(dir_dict_in.item()['hk_aqt_std'])
            self.dockwidget.hkClayMeanSpinBox.setValue(dir_dict_in.item()['hk_clay_mean'])
            self.dockwidget.hkClayStdevSpinBox.setValue(dir_dict_in.item()['hk_clay_std'])
            index = self.dockwidget.sedFluxComboBox.findText(dir_dict_in.item()['sed_flux'], Qt.MatchFixedString)
            if index >= 0:
                 self.dockwidget.sedFluxComboBox.setCurrentIndex(index)  
        #   plot the IC array based on combobox selection
        if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
            self.ic_plotWdg.plotSalinityArray(self.nc_dataset[13], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        else:
            self.ic_plotWdg.plotHeadElevationArray(self.nc_dataset[12], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        """
        
    #   action that imports stress periods for selected model into the tablewidget
    def onClickedRowStressPeriodModel(self, index = None):
        self.CS_model_selected = str(self.model_CS.data(index, Qt.DisplayRole))
        self.geology_model_selected = str(self.model_geology.data(index, Qt.DisplayRole))
        self.stress_periods_selected = str(self.model_stress_periods.data(index, Qt.DisplayRole))
        self.initial_conditions_selected = str(self.model_IC.data(index, Qt.DisplayRole))
        self.SEAWAT_parameters_selected = str(self.model_SEAWAT.data(index, Qt.DisplayRole))
        self.setAllFromSelectedModel()
        """
        csv_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.stress_periods_selected, 'temp_files', self.stress_periods_selected + '_SP_input.csv')
        self.dockwidget.SP_frame._addrow_from_csv(csv_path, self.rch_files_lst)    
        nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.stress_periods_selected, 'temp_files', self.stress_periods_selected + '_INPUT.nc')
        self.nc_dataset = readNetcdfSEAWATModelInput(nc_path)   
        #   plot ibound, geology and set the SP table to match the selection
        self.ibound_plotWdg.plotIBOUNDarray(self.nc_dataset[2], self.nc_dataset[3], self.nc_dataset[4], self.nc_dataset[7], self.nc_dataset[8],\
                                            self.nc_dataset[9], self.nc_dataset[10], self.nc_dataset[0], self.nc_dataset[1])
        self.geology_plotWdg.plotGeologyArray(self.nc_dataset[5], self.nc_dataset[3], self.nc_dataset[0], self.nc_dataset[1])  
        #   populate the various fields with the values from the dictionary
        dict_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', self.geology_model_selected + '_geo_dict.npy')
        if os.path.exists(dict_path):
            dir_dict_in = np.load(dict_path, allow_pickle = True)            
            self.dockwidget.randomScenarioSpinBox.setValue(dir_dict_in.item()['rand_seed_in'])
            self.dockwidget.aqfNSpinBox.setValue(dir_dict_in.item()['n_aqf_aqt_lrs'])
            self.dockwidget.pfactSpinBox.setValue(dir_dict_in.item()['p_fact'])
            self.dockwidget.sandPctSpinBox.setValue(dir_dict_in.item()['sand_pct'])
            self.dockwidget.mudPctSpinBox.setValue(dir_dict_in.item()['mud_pct'])
            self.dockwidget.erosionFactorSpinBox.setValue(dir_dict_in.item()['erosion_fact'])            
            self.dockwidget.shelfClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_shelf_thk'])
            self.dockwidget.slopeClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_slope_thk'])
            self.dockwidget.inlandClayStartSpinBox.setValue(dir_dict_in.item()['off_lay_start'])
            self.dockwidget.hkAqfMeanSpinBox.setValue(dir_dict_in.item()['hk_aqf_mean'])
            self.dockwidget.hkAqfStdevSpinBox.setValue(dir_dict_in.item()['hk_aqf_std'])
            self.dockwidget.hkAqtMeanSpinBox.setValue(dir_dict_in.item()['hk_aqt_mean'])
            self.dockwidget.hkAqtStdevSpinBox.setValue(dir_dict_in.item()['hk_aqt_std'])
            self.dockwidget.hkClayMeanSpinBox.setValue(dir_dict_in.item()['hk_clay_mean'])
            self.dockwidget.hkClayStdevSpinBox.setValue(dir_dict_in.item()['hk_clay_std'])
            index = self.dockwidget.sedFluxComboBox.findText(dir_dict_in.item()['sed_flux'], Qt.MatchFixedString)
            if index >= 0:
                 self.dockwidget.sedFluxComboBox.setCurrentIndex(index)  
        #   plot the IC array based on combobox selection
        if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
            self.ic_plotWdg.plotSalinityArray(self.nc_dataset[13], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        else:
            self.ic_plotWdg.plotHeadElevationArray(self.nc_dataset[12], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        """
        
    #   action that imports stress periods for selected model into the tablewidget
    def onClickedRowInitialConditionsModel(self, index = None):
        self.CS_model_selected = str(self.model_CS.data(index, Qt.DisplayRole))
        self.geology_model_selected = str(self.model_geology.data(index, Qt.DisplayRole))
        self.stress_periods_selected = str(self.model_stress_periods.data(index, Qt.DisplayRole))
        self.initial_conditions_selected = str(self.model_IC.data(index, Qt.DisplayRole))
        self.SEAWAT_parameters_selected = str(self.model_SEAWAT.data(index, Qt.DisplayRole))
        self.setAllFromSelectedModel()
        """
        nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.initial_conditions_selected, 'temp_files', self.initial_conditions_selected + '_INPUT.nc')
        self.nc_dataset = readNetcdfSEAWATModelInput(nc_path)   
        #   plot ibound, geology and set the SP table to match the selection
        self.ibound_plotWdg.plotIBOUNDarray(self.nc_dataset[2], self.nc_dataset[3], self.nc_dataset[4], self.nc_dataset[7], self.nc_dataset[8],\
                                            self.nc_dataset[9], self.nc_dataset[10], self.nc_dataset[0], self.nc_dataset[1])
        self.geology_plotWdg.plotGeologyArray(self.nc_dataset[5], self.nc_dataset[3], self.nc_dataset[0], self.nc_dataset[1])  
        #   populate the various fields with the values from the dictionary
        dict_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', self.geology_model_selected + '_geo_dict.npy')
        if os.path.exists(dict_path):
            dir_dict_in = np.load(dict_path, allow_pickle = True)            
            self.dockwidget.randomScenarioSpinBox.setValue(dir_dict_in.item()['rand_seed_in'])
            self.dockwidget.aqfNSpinBox.setValue(dir_dict_in.item()['n_aqf_aqt_lrs'])
            self.dockwidget.pfactSpinBox.setValue(dir_dict_in.item()['p_fact'])
            self.dockwidget.sandPctSpinBox.setValue(dir_dict_in.item()['sand_pct'])
            self.dockwidget.mudPctSpinBox.setValue(dir_dict_in.item()['mud_pct'])
            self.dockwidget.erosionFactorSpinBox.setValue(dir_dict_in.item()['erosion_fact'])            
            self.dockwidget.shelfClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_shelf_thk'])
            self.dockwidget.slopeClayThkSpinBox.setValue(dir_dict_in.item()['clay_cap_slope_thk'])
            self.dockwidget.inlandClayStartSpinBox.setValue(dir_dict_in.item()['off_lay_start'])
            self.dockwidget.hkAqfMeanSpinBox.setValue(dir_dict_in.item()['hk_aqf_mean'])
            self.dockwidget.hkAqfStdevSpinBox.setValue(dir_dict_in.item()['hk_aqf_std'])
            self.dockwidget.hkAqtMeanSpinBox.setValue(dir_dict_in.item()['hk_aqt_mean'])
            self.dockwidget.hkAqtStdevSpinBox.setValue(dir_dict_in.item()['hk_aqt_std'])
            self.dockwidget.hkClayMeanSpinBox.setValue(dir_dict_in.item()['hk_clay_mean'])
            self.dockwidget.hkClayStdevSpinBox.setValue(dir_dict_in.item()['hk_clay_std'])
            index = self.dockwidget.sedFluxComboBox.findText(dir_dict_in.item()['sed_flux'], Qt.MatchFixedString)
            if index >= 0:
                 self.dockwidget.sedFluxComboBox.setCurrentIndex(index)  
        csv_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.initial_conditions_selected, 'temp_files', self.initial_conditions_selected + '_SP_input.csv')
        self.dockwidget.SP_frame._addrow_from_csv(csv_path, self.rch_files_lst)    
        #   plot the IC array based on combobox selection
        if self.dockwidget.ICPlotComboBox.currentText() == 'Salinity':
            self.ic_plotWdg.plotSalinityArray(self.nc_dataset[13], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        else:
            self.ic_plotWdg.plotHeadElevationArray(self.nc_dataset[12], self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        """
    
    #   action that imports SEAWAT packages parameter values for selected model into the tablewidget
    def onClickedRowSEAWATModel(self, index = None):
        self.CS_model_selected = str(self.model_CS.data(index, Qt.DisplayRole))
        self.geology_model_selected = str(self.model_geology.data(index, Qt.DisplayRole))
        self.stress_periods_selected = str(self.model_stress_periods.data(index, Qt.DisplayRole))
        self.initial_conditions_selected = str(self.model_IC.data(index, Qt.DisplayRole))
        self.SEAWAT_parameters_selected = str(self.model_SEAWAT.data(index, Qt.DisplayRole))
        self.setAllFromSelectedModel()
            
    #   adding the model will load data, build the SEAWAT model object and put it in the list of models view
    def addModel(self):
        #   read in different raster values from the input directories - DEM and geology only so far
        self.mapTool.loadRasterInfoToCrossSection(1, 'DEM', self.dockwidget.DEMLineEdit.text())        
        self.mapTool.loadRasterInfoToCrossSection(1, 'upp_sed_thk_dir', self.dockwidget.UpperSedThkLineEdit.text())
        self.mapTool.loadRasterInfoToCrossSection(3600 * 24, 'hk_aqf_dir', self.dockwidget.AqfHkLineEdit.text())
        self.mapTool.loadRasterInfoToCrossSection(1, 'hk_aqt_dir', self.dockwidget.AqtHkLineEdit.text()) 
        #   create a new SEAWAT model
        self.CS_model_obj = CS_model(self.dockwidget.modelNameLineEdit.text(), self.dockwidget.colWidthSpinBox.value(),\
                                         self.dockwidget.layThkSpinBox.value(), self.dockwidget.inlExtSpinBox.value() * -1,
                                         self.dockwidget.inlThkSpinBox.value(), self.dockwidget.cstThkSpinBox.value(),\
                                         self.dockwidget.cntShlfThkSpinBox.value(), self.dockwidget.offThkSpinBox.value(),\
                                         self.mapTool.csv_dir)   
        self.CS_model_obj.create_IBOUND_arr()
        self.CS_model_obj.create_NC_file()
        self.CS_model_obj.create_SP_file()
        self.CS_model_obj.create_SEAWAT_pckg_dictionaries()
        self.addCSModel(self.CS_model_obj.name)
        self.addGeologyModel(self.CS_model_obj.name)        
        self.addStressPeriodsModel(self.CS_model_obj.name)
        self.addIinitalConditionsModel(self.CS_model_obj.name)
        self.addSEAWATModel(self.CS_model_obj.name)
        self.addSEAWATModel_visualization(self.CS_model_obj.name)
        #   reload the RCH files from folder
        self.load_RCH_files_from_folder()
        self.dockwidget.SP_frame._addrow_from_csv(os.path.join(self.dockwidget.outDirLineEdit.text(), self.dockwidget.modelNameLineEdit.text(), 'temp_files', self.dockwidget.modelNameLineEdit.text() + '_SP_input.csv'), self.rch_files_lst)        
        
        #   assign to variables
        self.ibound_array = self.CS_model_obj.ibound_arr[:, 0, :]
        self.ic_head_array = self.CS_model_obj.ic_head_arr[:, 0, :]
        self.ic_salinity_array = self.CS_model_obj.ic_salinity_arr[:, 0, :]
        self.cont_shlf_edge = self.CS_model_obj.sb_pt
        self.x_lst = self.CS_model_obj.x_mid_cell_lst
        self.y_lst = self.CS_model_obj.y_mid_cell_lst
        self.top_elev = self.CS_model_obj.top_elev_lst
        self.bot_elev = self.CS_model_obj.bot_elev_lst
        self.x_shlf = self.CS_model_obj.x_shelf_edge        
        #   plot the cross-section onto the map, also adapt the map zoom so it centers on the cross-section
        cs_name = os.path.join(self.dockwidget.outDirLineEdit.text(), self.dockwidget.modelNameLineEdit.text(), 'temp_files', 'cs_points.csv')
        #self.plotCsLine(self.x_lst[0], self.x_lst[-1], self.dockwidget.modelNameLineEdit.text(), cs_name) 
        self.plotCsLine(min(self.x_lst), max(self.x_lst), self.dockwidget.modelNameLineEdit.text(), cs_name)         
        #   plot the IBOUND array in the plot area, also plot a dummy geology array in the geology frame - basically showing IBOUND array
        self.ibound_plotWdg.plotIBOUNDarray(self.CS_model_obj.ibound_arr, self.CS_model_obj.top_elev_lst, self.CS_model_obj.bot_elev_lst,\
                                            [self.CS_model_obj.y_bot_st, self.CS_model_obj.x_st], [self.CS_model_obj.y_bot_cst, self.CS_model_obj.x_coast],\
                                            [self.CS_model_obj.y_bot_shlf, self.CS_model_obj.x_shelf_edge], [self.CS_model_obj.y_bot_fos, self.CS_model_obj.x_fos],\
                                            self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)
        self.geology_plotWdg.plotGeologyArray(self.CS_model_obj.ibound_arr, self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        self.ic_plotWdg.plotHeadElevationArray(self.ic_head_array, self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        
        #self.dockwidget.SEAWAT_packages_frame.add_row_initial()


    def cleanIBOUND(self): 
        self.CS_model_obj.clean_IBOUND_array()
        self.CS_model_obj.create_NC_file()        
        #   assign to variables
        self.ibound_array = self.CS_model_obj.ibound_arr[:, 0, :]
        self.ic_head_array = self.CS_model_obj.ic_head_arr[:, 0, :]
        self.ic_salinity_array = self.CS_model_obj.ic_salinity_arr[:, 0, :]    
        self.cont_shlf_edge = self.CS_model_obj.sb_pt
        self.x_lst = self.CS_model_obj.x_mid_cell_lst
        self.y_lst = self.CS_model_obj.y_mid_cell_lst
        self.top_elev = self.CS_model_obj.top_elev_lst
        self.bot_elev = self.CS_model_obj.bot_elev_lst
        self.x_shlf = self.CS_model_obj.x_shelf_edge
        #   plot the IBOUND array in the plot area, also plot a dummy geology array in the geology frame - basically showing IBOUND array
        self.ibound_plotWdg.plotIBOUNDarray(self.CS_model_obj.ibound_arr, self.CS_model_obj.top_elev_lst, self.CS_model_obj.bot_elev_lst,\
                                            [self.CS_model_obj.y_bot_st, self.CS_model_obj.x_st], [self.CS_model_obj.y_bot_cst, self.CS_model_obj.x_coast],\
                                            [self.CS_model_obj.y_bot_shlf, self.CS_model_obj.x_shelf_edge], [self.CS_model_obj.y_bot_fos, self.CS_model_obj.x_fos],\
                                            self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)
        self.geology_plotWdg.plotGeologyArray(self.CS_model_obj.ibound_arr, self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                
        self.ic_plotWdg.plotHeadElevationArray(self.ic_head_array, self.CS_model_obj.top_elev_lst, self.CS_model_obj.x_mid_cell_lst, self.CS_model_obj.y_mid_cell_lst)                

    def randomizeGeologyScenario(self):
        new_val = random.randint(self.dockwidget.randomScenarioSpinBox.minimum(), self.dockwidget.randomScenarioSpinBox.maximum())
        self.dockwidget.randomScenarioSpinBox.setValue(new_val)

    def plotGeologyProfile(self):
        """  TO CHANGE, LOOK INTO - the off_lay_thk_ratio is now set to mud_pct, maybe adapt in future to be specified by user?     
             It specifies the percentage of mud (aquitard) layer cells that will be assigned the clay HK.                   """          

        #   find the coastal index - that will determine the limit between the inland and offshore domain
        #x_st = round(self.x_lst[0] + (self.x_lst[0] - self.x_lst[1]) / 2., 3)
        #cst_offset_val = next((x for x in self.top_elev[:int(abs(x_st) * 10)] if x < -10.0), None)
        #if not cst_offset_val:
        #    cst_offset_val = next((x for x in self.top_elev[int(abs(x_st) * 10):] if x < 0.0), None)
        #    cst_offset_idx = int(abs(x_st) * 10) + self.top_elev[int(abs(x_st) * 10):].index(cst_offset_val) - 1
        #else:
        #    cst_offset_idx = self.top_elev.index(cst_offset_val) - 1
        #cst_offset_plot = round(x_st + cst_offset_idx / (1000. / 100), 2) #  - to get the distance in km    
        #cst_idx_geo = int(abs(x_st - cst_offset_plot) * 10)
        self.new_hk_arr = create_geology_profile(self.dockwidget.randomScenarioSpinBox.value(), self.dockwidget.aqfNSpinBox.value(), self.dockwidget.pfactSpinBox.value(),\
                                                 self.dockwidget.mudPctSpinBox.value(), self.dockwidget.mudPctSpinBox.value(), self.dockwidget.erosionFactorSpinBox.value(),\
                                                 self.dockwidget.shelfClayThkSpinBox.value(), self.dockwidget.slopeClayThkSpinBox.value(), self.dockwidget.inlandClayStartSpinBox.value(),\
                                                 self.dockwidget.sedFluxComboBox.currentText(), False, True, True, self.dockwidget.hkAqfMeanSpinBox.value(), self.dockwidget.hkAqfStdevSpinBox.value(),\
                                                 self.dockwidget.hkAqtMeanSpinBox.value(), self.dockwidget.hkAqtStdevSpinBox.value(), self.cont_shlf_edge,\
                                                 self.dockwidget.hkClayMeanSpinBox.value(), self.dockwidget.hkClayStdevSpinBox.value(), self.x_lst, self.y_lst, self.ibound_array,\
                                                 self.top_elev, self.bot_elev, self.x_shlf, None, 100., 10.)
        #   plot the new HK array
        self.geology_plotWdg.plotGeologyArray(self.new_hk_arr, self.top_elev, self.x_lst, self.y_lst)                         
        
    #   save selected geology
    def saveGeologyProfile(self):
        #   plot the selected profile 
        #geology_model_selected = str(self.model_geology.data(index, Qt.DisplayRole))
        nc_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', self.geology_model_selected + '_INPUT.nc')
        #self.nc_dataset = readNetcdfSEAWATModelInput(nc_path)      
        updateNetcdfGeologyArray(nc_path, self.new_hk_arr, self.new_hk_arr * self.dockwidget.anisotropySpinBox.value())
        #   also save all the values as numpy dictionary
        dict_path = os.path.join(self.dockwidget.outDirLineEdit.text(), self.geology_model_selected, 'temp_files', self.geology_model_selected + '_geo_dict.npy')
        save_geo_dict(dict_path, (self.dockwidget.randomScenarioSpinBox.value()), (self.dockwidget.aqfNSpinBox.value()), (self.dockwidget.pfactSpinBox.value()),\
                      (self.dockwidget.sandPctSpinBox.value()), (self.dockwidget.mudPctSpinBox.value()), (self.dockwidget.erosionFactorSpinBox.value()),\
                      (self.dockwidget.shelfClayThkSpinBox.value()), (self.dockwidget.slopeClayThkSpinBox.value()), (self.dockwidget.inlandClayStartSpinBox.value()),\
                      (self.dockwidget.sedFluxComboBox.currentText()), (self.dockwidget.hkAqfMeanSpinBox.value()), (self.dockwidget.hkAqfStdevSpinBox.value()),\
                      (self.dockwidget.hkAqtMeanSpinBox.value()), (self.dockwidget.hkAqtStdevSpinBox.value()), (self.dockwidget.hkClayMeanSpinBox.value()),\
                      (self.dockwidget.hkClayStdevSpinBox.value()))
                          
    def updateSpinBox(self, inl_ext, off_ext):
        self.dockwidget.inlExtSpinBox.setValue(inl_ext)
        self.dockwidget.offExtSpinBox.setValue(off_ext)   
        
    #   action that will change the extent of the cross-section based on the spinBox values
    def changeExtentCS(self):
        #   make sure the map.Tool exists, if not then no action will happen
        if self.mapTool:
            self.mapTool.changeExtentCrossSection(self.dockwidget.inlExtSpinBox.value(), self.dockwidget.offExtSpinBox.value(), perpendicular = True)
        else:
            self.mapTool = CoordTool(self.iface.mapCanvas())
            self.iface.mapCanvas().setMapTool(self.mapTool)            
            self.mapTool.changeExtentCrossSection(self.dockwidget.inlExtSpinBox.value(), self.dockwidget.offExtSpinBox.value(), perpendicular = True)
            
    #   save the stress period table to csv
    def saveSpTableToCsv(self):
        self.dockwidget.SP_frame._save_to_csv(os.path.join(self.dockwidget.outDirLineEdit.text(), self.stress_periods_selected, 'temp_files', self.stress_periods_selected + '_SP_input.csv'))



           